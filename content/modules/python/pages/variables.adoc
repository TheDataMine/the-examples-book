= Python Variables

== Overview
Python variables are very similar to how variables are used in R. The primary difference is that instead of using `<-` or `->` to assign variables, Python uses a single `=`. 

Python has a few key differences from R in regards to variable behavior. Information on variable assignment in Python can be found in the <<variable assignment, Variable Assigment>> section below. 

Similar to other programming languages Python has several core variable types. Overview of each variable type are included below:

* <<None, None>>
* <<NaN, NaN>>
* <<bool, bool>>
* <<str, str>>
* <<int, int>>
* <<float, float>>
* <<complex, complex>>


== Variable Assigment 

[source, python]
----
my_variable = 4
----

This declares a variable with a value of 4. 

[IMPORTANT]
====
Actually this is technically not true. Numbers between -5 and 256 (inclusive) are already pre-declared and exist within Python's memory before you assigned the value to my_var. The = operator simply forces my_var to point to that value that already exists! That is right, my_var is technically a pointer.
====

One of the most important differences between variables in R and Python is what is happening in the background. Take the code example below: 

[source, python]
----
my_variable = 4
new_variable = my_variable
my_variable = my_variable + 1
print(f"my_variable: {my_variable}\nnew_variable: {new_variable}")
----
----
## my_variable: 5
## my_variable: 4
----
[source, python]
----
my_variable = [4,]
new_variable = my_variable
my_variable[0] = my_variable[0] + 1
print(f"my_variable: {my_variable}\nnew_variable: {new_variable}")
----
----
## my_variable: [5]
## new_variable: [5]
----

The first chunk of code behaves as you'd expect because `int` values are immutable, meaning the values cannot be changed. As a result, when we assign `my_variable = my_variable + 1`, `my_variables` value isn't changing. Instead `my_variable` is just being pointed to a different value (in this case 5). In comparison `new_variable` still points to the value of 4. 

The second chunk of code is different because it is dealing with a mutable `list`. We first assign the first value (0 index) of the list to a value of 4. We then assign `my_variable` to `new_variable`. Unlike the first example, this does **not** copy the values. Instead both `my_variable` and `new_variable` point to the same mutable list object. When we then change the value of the list by 1 the change is reflected in each variable since they are pointing to the same object. 

An excellent article goes into more detail and can be found https://realpython.com/pointers-in-python/[here]. 

== None

`None` is a keyword used to define a null value. This would be the Python equivalent to R's `NULL`. If used in an if statement, `None` represents `False`. This does not mean `None` == `False`, in fact: 

[source, python]
----
print(None == False)
----

----
## False
----

Even though `None` can represent `False` in an if statement Python does not evaluate the two as equivalent. 

== NaN
The difference between `NaN` and `None` in Python can be somewhat confusing. The `NaN` value stand for `not a number` and is commonly used to reference missing data. `NaN` values can be tricky because technically Python sees them as having a numerical value. This means that when doing something like the average of a row of data they can change the output in expected ways. 