= matplotlib

As mentioned, when starting with Python the most common plotting package is often `matplotlib`. It's an easy and straightforward plotting tool with a surprising amount of depth. Like any package it also has pluses and minuses. 

Importing `matplotlib` for use in a project is pretty straightforward: 

* <<barplot, barplot>>

[source, python]
----
import matplotlib.pyplot as plt
----

*Note:* You don't have to include it as `plt` but it is a common occurance when writing code. Similar to how you often see `pd` for `pandas` or `np` for `numpy`. 

.Documentation Definition
****
`matplotlib.pyplot` is a collection of functions that make `matplotlib` work like MATLAB. Each `pyplot` function makes some change to a figure: e.g., create a figure, creating a plotting area in a figure, plots some lines in a plotting area, decorates the plot with labels, etc.
****

For those of us who aren't familiar with MATLAB the `pyplot` functionality creates a plotting object. Once you have the object created you can change parameters, add visualizations, change color schemes, and otherwise update the plot. Once you are finished you can close the plotting object.

== barplot

Barplots can take many forms. They are most often utilized when comparing change over time or comparisons between categories for a data set. As with many of the plotting types `matplotlib` has the built-in `barplot` function to create the visualizations. 

[source, python]
----
import pandas as pd
import matplotlib.pyplot as plt

myDF = pd.read_csv("/depot/datamine/data/precip/precip.csv")
plt.bar(myDF['place'].iloc[:10], myDF['precip'].iloc[:10])
plt.show()
----

image::bar_1.png[Initial Bar Plot, width=792, height=500, loading=lazy, title="First bar plot"]

[source, python]
----
plt.close()
----

As we can see in the first example, we have a bar plot but the x-axis labels are a bit hard to read. What if we turned the labels to be vertical?

[source, python]
----
import pandas as pd
import matplotlib.pyplot as plt

myDF = pd.read_csv("/depot/datamine/data/precip/precip.csv")
plt.bar(myDF['place'].iloc[:10], myDF['precip'].iloc[:10])
plt.xticks(myDF['place'].iloc[:10], rotation='vertical')
plt.show()
----

image::bar_2.png[Bar Plot with Vertical Labels, width=792, height=500, loading=lazy, title="Verticle x-axis Labels"]

[source, python]
----
plt.close()
----

Now in this case, since we are using Jupyter Lab, the axis labels fit neatly in the graph. However, in many cases the labels will end up looking like the plot below. 

image::bar_3.png[Cut Off x-axis Labels, width=792, height=500, loading=lazy, title="Cut Off x-axis Labels"]

If we wanted to add some additional space to the bottom of the plot we could do so with the `subplots_adjust` argument. 

[source, python]
----
import pandas as pd
import matplotlib.pyplot as plt

myDF = pd.read_csv("/depot/datamine/data/precip/precip.csv")
plt.bar(myDF['place'].iloc[:10], myDF['precip'].iloc[:10])
plt.xticks(myDF['place'].iloc[:10], rotation='vertical')
plt.subplots_adjust(bottom=0.2)
plt.show()
----

image::bar_4.png[Adjusted x-axis Labels, width=792, height=500, loading=lazy, title="Adjusted x-axis Labels"]

[source, python]
----
plt.close()
----

In Jupyter Lab the difference may not be very apparent, but in other environments the `subplots_adjust` argument can be utilized to reshape your plotting object as needed. 

Now that we have the x-axis labels adjusted we can work on adding a title and a label for the y-axis. 

[source, python]
----
import pandas as pd
import matplotlib.pyplot as plt

myDF = pd.read_csv("/depot/datamine/data/precip/precip.csv")
plt.bar(myDF['place'].iloc[:10], myDF['precip'].iloc[:10])
plt.xticks(myDF['place'].iloc[:10], rotation='vertical')
plt.subplots_adjust(bottom=0.3)
plt.title("Average Precipitation")
plt.ylabel("Inches of rain")
plt.show()
----

image::bar_5.png[Adding a Title and y-axis Label, width=792, height=500, loading=lazy, title="Updated Title and y-axis Label"]

[source, python]
----
plt.close()
----

We seem to have the basics of the plot set. The next most adjusted parameter is the color! How do we change the color?

[source, python]
----
import pandas as pd
import matplotlib.pyplot as plt

myDF = pd.read_csv("/depot/datamine/data/precip/precip.csv")
plt.bar(myDF['place'].iloc[:10], myDF['precip'].iloc[:10], color="#FF826B")
plt.xticks(myDF['place'].iloc[:10], rotation='vertical')
plt.subplots_adjust(bottom=0.3)
plt.title("Average Precipitation")
plt.ylabel("Inches of rain")
plt.show()
----

image::bar_6.png[Changing the Plot Color, width=792, height=500, loading=lazy, title="Changing the Plot Color"]

----
plt.close()
----

The example above is using what's known as an RGB or hex (red, green, blue) string. In this case it's a way to indicate color values using letters and numbers. If you're interested to read further check out the https://matplotlib.org/stable/api/colors_api.html[matplotlib documentation] for reference. 

In addition to the hex colors matplotlib has a set of https://matplotlib.org/stable/gallery/color/named_colors.html[named colors]. These allow you to pass the color as a plain text name, but it does not allow the freedom of hex color customization. 

Now that we know a bit more about choosing colors in matplotlib, can we color the different cities in our graph?

[source, python]
----
import pandas as pd
import matplotlib.pyplot as plt

myDF = pd.read_csv("/depot/datamine/data/precip/precip.csv")
colors = ("#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462", "#B3DE69", "#FCCDE5", "#D9D9D9", "#BC80BD",)
plt.bar(myDF['place'].iloc[:10], myDF['precip'].iloc[:10], color=colors)
plt.xticks(myDF['place'].iloc[:10], rotation='vertical')
plt.subplots_adjust(bottom=0.3)
plt.title("Average Precipitation")
plt.ylabel("Inches of rain")
plt.show()
----

image::bar_7.png[Colored by City, width=792, height=500, loading=lazy, title="Colored by City"]

[source, python]
----
plt.close()
----

Now we can dive a bit deeper into plot customization. What if instead of x-labels we wanted to add a legend to the plot?

[source, python]
----
import pandas as pd
import matplotlib.pyplot as plt

myDF = pd.read_csv("/depot/datamine/data/precip/precip.csv")
colors = ("#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462", "#B3DE69", "#FCCDE5", "#D9D9D9", "#BC80BD",)
plt.bar(myDF['place'].iloc[:10], myDF['precip'].iloc[:10], color=colors)
plt.title("Average Precipitation")
plt.ylabel("Inches of rain")
----

[source, python]
----
labels = {place:color for place, color in zip(myDF['place'].iloc[:10].to_list(), colors[:10])}
print(labels)
----

----
{'Mobile': '#8DD3C7', 'Juneau': '#FFFFB3', 'Phoenix': '#BEBADA', 'Little Rock': '#FB8072', 'Los Angeles': '#80B1D3', 'Sacramento': '#FDB462', 'San Francisco': '#B3DE69', 'Denver': '#FCCDE5', 'Hartford': '#D9D9D9', 'Wilmington': '#BC80BD'}
----

[source, python]
----
handles = [plt.Rectangle((0,0),1,1, color=color) for label,color in labels.items()]
plt.legend(handles=handles, labels=labels.keys())
plt.show()
----

image::bar_8.png[Adding a Legend, width=792, height=500, loading=lazy, title="Adding a Legend"]

[source, python]
----
plt.close()
----

It's not too bad, but just like with the x-axis labels above we have a little formatting to fix. We used `subplots_adjust` to modify the space at the bottom of the plot. In this case we can pass the `loc` argument to the `plt.legend()` method in order to update the location. If you'd like to learn more about the different `loc` locations, check out the https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.legend.html[matplotlib doc].

[source, python]
----
import pandas as pd
import matplotlib.pyplot as plt

myDF = pd.read_csv("/depot/datamine/data/precip/precip.csv")
colors = ("#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462", "#B3DE69", "#FCCDE5", "#D9D9D9", "#BC80BD",)
plt.bar(myDF['place'].iloc[:10], myDF['precip'].iloc[:10], color=colors)
plt.title("Average Precipitation")
plt.ylabel("Inches of rain")
labels = {place:color for place, color in zip(myDF['place'].iloc[:10].to_list(), colors[:10])}
plt.xticks('') #This removes the x-axis labels

handles = [plt.Rectangle((0,0),1,1, color=color) for label,color in labels.items()]
plt.legend(handles=handles, labels=labels.keys(), loc=1)
plt.show()
----

image::bar_9.png[Moving the Legend, width=792, height=500, loading=lazy, title="Moving the Legend"]

[source, python]
----
plt.close()
----

This is improved, but we are still covering some of the data in the plot. Luckily `matplotlib` has a different function `bbox_to_anchor` that we can use to push the legend outside of the plot. 

[source, python]
----
import pandas as pd
import matplotlib.pyplot as plt

myDF = pd.read_csv("/depot/datamine/data/precip/precip.csv")
colors = ("#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462", "#B3DE69", "#FCCDE5", "#D9D9D9", "#BC80BD",)
plt.bar(myDF['place'].iloc[:10], myDF['precip'].iloc[:10], color=colors)
plt.title("Average Precipitation")
plt.ylabel("Inches of rain")
labels = {place:color for place, color in zip(myDF['place'].iloc[:10].to_list(), colors[:10])}
plt.xticks('')

handles = [plt.Rectangle((0,0),1,1, color=color) for label,color in labels.items()]
plt.legend(handles=handles, labels=labels.keys(), bbox_to_anchor=(1.35, 1))
plt.show()
----

image::bar_10.png[Legend Outside the Plot, width=792, height=500, loading=lazy, title="Legend Outside the Plot"]

[source, python]
----
plt.close()
----

In Jupyter Lab this gives us what we are looking for! We have now moved the legend outside of the plot and everything is easy to view. *Note* depending on the environment that you are running the code in you may have to play around with the `bbox_to_anchor` parameters to make the legend fit. Also, if you can't see all the text in the legend trying adding `subplots_adjust` back to the code with the `right=` argument to adjust the plot sizing. 

Just for a final customization lets make the legend border white (remove it). 

[source, python]
----
import pandas as pd
import matplotlib.pyplot as plt

myDF = pd.read_csv("/depot/datamine/data/precip/precip.csv")
colors = ("#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462", "#B3DE69", "#FCCDE5", "#D9D9D9", "#BC80BD",)
plt.bar(myDF['place'].iloc[:10], myDF['precip'].iloc[:10], color=colors)
plt.title("Average Precipitation")
plt.ylabel("Inches of rain")
labels = {place:color for place, color in zip(myDF['place'].iloc[:10].to_list(), colors[:10])}
plt.xticks('')

handles = [plt.Rectangle((0,0),1,1, color=color) for label,color in labels.items()]
plt.legend(handles=handles, labels=labels.keys(), bbox_to_anchor=(1.35, 1), edgecolor='white')
plt.show()
----

image::bar_11.png[Legend Formatting, width=792, height=500, loading=lazy, title="Legend Formatting"]

[source, python]
----
plt.close()
----

This just starts to scratch the surface of what is possible with `matplotlib` but it does show the deep customization that is possible via the package. 