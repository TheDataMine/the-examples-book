= Writing Functions

== Introduction

While functions are more emphasized in object-oriented languages, the fundamental idea of functions is packing several actions into one unit that you yourself define, which is something that applies to all programming languages. When we're dealing with longer and more complicated projects, writing Python functions is crucial for making the code readable.

=== Function Signature & Annotations

Understanding the syntax and dialogue surrounding a function is an important step for both reading instructions about functions and communicating what your function does. Consider the following code: 

[source,python]
----
def word_count(sentence: str) -> int:
    """
    word_count is a function that accepts a sentence as an argument,
    and returns the number of words in the sentence.

    Args:
        sentence (str): The sentence for which we are counting the words.

    Returns:
        int: The number of words in the sentence
    """
    result = len(sentence.split())
    return result
    
test_sentence = "this is a sentence that has eight words."
word_count(test_sentence)
----

----
8
----

There are a few things we need to define and clarify: 

* *Function name*: The name of the function immediately follows the `def` keyword. This function is called `word_count` and we will refer to functions by name in most cases.
* *Parameters*: This is another term for the function's input, of which there are 0+. There is one parameter in this function, called `sentence`.
** In Python, you can include the data type after the parameter name. Above, this is `: str` to specify that `sentence` is a string. We recommend you specify because the methods you apply to the parameter might not work if the parameter is a different data type.
** *Output*: This is another optional part of a function where you can specify what the function returns. In the example, this is represented by `-> int`. Functions can have 0 or more outputs.

All of the above qualities define the *signature* of the function, and as you read, many of them are optional. We could write `word_count` in the following way and it would be the exact same: 

[source,python]
----
def word_count(sentence):
    """
    word_count is a function that accepts a sentence as an argument,
    and returns the number of words in the sentence.

    Args:
        sentence (str): The sentence for which we are counting the words.

    Returns:
        int: The number of words in the sentence
    """
    result = len(sentence.split())
    return result
    
test_sentence = "this is a sentence that has eight words."
word_count(test_sentence)
----

----
8
----

The umbrella term *function annotations* encompasses all the optional parts of a function's signature. Though optional, it's recommended to include them in larger projects for clarity and to make your code look more "professional."

{sp}+

=== Helper Functions

Functions can have helper functions nested within them, with the goal of reducing complexity or increasing clarity. For example, let's say we wanted our function to strip all punctuation before counting the words:

[source,python]
----
import string

def word_count(sentence: str) -> int:
    """
    word_count is a function that accepts a sentence as an argument,
    and returns the number of words in the sentence.

    Args:
        sentence (str): The sentence for which we are counting the words.

    Returns:
        int: The number of words in the sentence
    """
    
    def _strip_punctuation(sentence: str):
        """
        helper function to strip punctuation.
        """
        return sentence.translate(str.maketrans('', '', string.punctuation))
    
    sentence_no_punc = _strip_punctuation(sentence)
    result = len(sentence_no_punc.split())
    return result
    
test_sentence = "this is a sentence - it has eight words."
word_count(test_sentence)
----

----
8
----

Here, our helper function is named `_strip_punctuation`. If you try to call helper functions outside of `word_count`, you will get an error, as it is defined within the *scope* of `word_count` and is not available outside that scope. In this example, `word_count` is the "caller" while `_strip_punctuation` is the "callee."

[TIP]
====
You can use your own syntax to clarify helper functions. Here, we use a preceding "_" to hint that the function is just for internal use.
====

{sp}+

In Python, functions can be passed to other functions as arguments. If a function accepts another function as an argument _or_ returns function(s), we refer to them as *higher-order functions*. Some examples of higher-order functions in Python are `map`, `filter`, and `reduce`. If a function is used as an argument in another function, we refer to it as a *callback* function.

{sp}+

=== Packing & Unpacking

Say we have a function that returns a list of strings depending on how many matches are found within a paragraph, which returns `n` strings that match. Now say we want to put this output in a higher-order function and manipulate the matches in some way. How many parameters will we need for the higher-order function? Well, in short...we don't know. It's `n`, but `n` will change depending on the callback function's input. In this section, we discuss `*args` and `**kwargs`, two ways of accounting for variably-long parameters.

A more formal way of saying `*args` is _argument tuple packing_. Here's a few demonstrations: 

[source,python]
----
def sum_then_multiply_by_x(x = 0, *args):
    print(args)
    return sum(args) * x

print(sum_then_multiply_by_x(2, 1, 2, 3))
----

----
(1, 2, 3)
12
----

[source,python]
----
print(sum_then_multiply_by_x(2, 1, 2, 3, 4))
----

----
(1, 2, 3, 4)
20
----

[source,python]
----
print(sum_then_multiply_by_x(2, 1, 2, 3, 4, 5))
----

----
(1, 2, 3, 4, 5)
30
----

Here, every argument passed after the `x` argument is _packed_ into a tuple called `*args`. As you can see, you can pass any number of arguments and the function won't break. Awesome!

We've covered packing, so what about unpacking? Can we unpack an `n`-sized tuple into a function with `n` arguments? As a matter of fact, that's exactly how it works. Take the following example: 

[source,python]
----
def print_boo_YAH(boo, yah):
    print(f'{boo}{yah.upper()}')
    
# normally we would call this function like so:
print_boo_YAH("first", "second")
----

----
firstSECOND
----
[source,python]
----
# but we can also call this function in this way: 
words = ("boo", "yah")
print_boo_YAH(*words)
----

----
booYAH
----

Pay mind to the asterisk before the tuple parameter. Without it, tuple unpacking will not work.

{sp}+

Now that we have `\*args` established, we can discuss `**kwargs` for 