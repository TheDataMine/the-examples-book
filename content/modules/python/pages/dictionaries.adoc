= Dictionaries

* <<Overview, Overview>>
* <<Dictionary Methods, Dictionary Methods>>

== Overview

Dictionaries, commonly reffered to as dicts, are used to store key:value pairs. Under the hood, dicts are hash tables (or hash maps). Even with extremly large sets of data, dicts are able to very quickly add, remove, and search for data on average. Dicts are able to accomplish this at the expense of space.

There are two ways of declaring a dict, you can either use an empty or populated set of curly braces `{}`, or the `dict()` keyword.

[source, python]
----
#declaring dicts
my_dict = {}
print(type(my_dict))
my_dict = {"class": "Stat 190",
           "professor": "Mark Daniel Ward",
           "time": "8:30 AM - 9:20 AM"}
----

----
## <class 'dict'>
----

[source, python]
----
#declaring dicts
my_dict = dict()
print(type(my_dict))
----

----
## <class 'dict'>
----

[source, python]
----
my_dict = {"class": "Stat 190",
           "professor": "Mark Daniel Ward",
           "time": "8:30 AM - 9:20 AM"}
print(type(my_dict))
----

----
## <class 'dict'>
----

However, Dicts are not the only data type that utilizes the curly braces for initialization. The following variable is not a dict, but rather a set.

[source, python]
----
not_a_dict = {"John", "Jill","Ellen"}
print(type(not_a_dict))
----

----
## <class 'set'>
----

== Dictionary Methods

There are two primary ways of retrieving information from a dict. One is to use the `get` method, and the other is to use square brackets and strings.

[source, python]
----
my_dict = {"class": "Stat 190",
           "professor": "Mark Daniel Ward",
           "time": "8:30 AM - 9:20 AM"}

print(my_dict["class"])
print(my_dict.get("class"))

#returns "Stat 190"
----

However, when a key that is not present in the dictionary is being accessed, the methods function differently.

[source, python]
----
my_dict = {"class": "Stat 190",
           "professor": "Mark Daniel Ward",
           "time": "8:30 AM - 9:20 AM"}

print(my_dict["name"])
print(my_dict.get("name"))

# get() method returns None
# my_dict[key] returns a KeyError exception because the key, "name" doesn't exist
----

The following is a table of dict methods from https://www.w3schools.com/python/python_ref_dictionary.asp[w3schools.com]

|===
| Method | Description

| clear() | Removes all the elements from the dictionary

| copy() | Removes a copy of the dictionary

| fromkeys() | Returns a dictionary with the specified keys and value

| get() | Returns the value of the specified key, or None if key doesn't exist

| items() | Returns a list containing a tuple for each key value pair

| keys() | Returns a list containing the dictionary's keys

| pop() | Removes and returns the element with the specified key

| popitem() | Removes the last inserted key-value pair

| setdefault() | returns the value of the specified key. If the key doesn't exist: insert the key, with the specified value

| update() | Update the dictionary with the specified key-value pairs

| values() | Returns a list of all the values in the dictionary
|===

Dictionaries, like lists, are mutable, meaning that thier value can be changed after declaration.

[source, python]
----
my_dict = {"class": "Stat 190", 
           "professor": "Mark Daniel Ward",
           "time": "8:30 AM - 9:20 AM"}

# currently my_dict["time"] has "8:30 AM - 9:20 AM", however after the following line, value is changed to the new value.

my_dict["time"] = "9:30 AM - 10:20 AM"
print(my_dict)
----

----
{"class": "Stat 190", 
 "professor": "Mark Daniel Ward",
 "time": "9:30 AM - 10:20 AM"}
----

Items stored in Dictionary are ordered by the key (as you can see in the previous example). This applies to all Python from Verssion 3.7 When a key-value pair is appended, where the key already exists in the variable, the value of that key will be overwritten by the value of the new key.

https://www.w3schools.com/python/python_dictionaries.asp