= Writing Functions

In a nutshell, a function is a set of instructions or actions packaged together in a single definition or unit. Typically, function accept 0 or more _arguments_ as input, and returns 0 or more results as output. The following is an example of a function in `Python`:

[source, Python]
----
In a nutshell, a function is a set of instructions or actions packaged together in a single definition or unit. Typically, function accept 0 or more arguments as input, and returns 0 or more results as output. The following is an example of a function in Python:
----

[source, Python]
----
7
----

The function is named `word_count`. The function has a single _parameter_ named `sentence``. The function returns a single value, `result`, which is the number of words in the provided sentence. `test_sentence` is the _argument_ to `word_count`. An _argument_ is the actual value passed to the function. We _pass_ values to functions -- this just means we use the values as _arguments_ to the function. The _parameter_, `sentence`, is the name shown in the function definition.

Functions can have helper functions. A helper function is a function defined and used within another function in order to reduce complexity or make the task at hand more clear. For example, let's say we wanted our function to strip all punctuation before counting the words:

[source, Python]
----
import string

def word_count(sentence: str) -> int:
    """
    word_count is a function that accepts a sentence as an argument,
    and returns the number of words in the sentence.

    Args:
        sentence (str): The sentence for which we are counting the words.

    Returns:
        int: The number of words in the sentence
    """
    
    def _strip_punctuation(sentence: str):
        """
        helper function to strip punctuation.
        """
        return sentence.translate(str.maketrans('', '', string.punctuation))
    
    sentence_no_punc = _strip_punctuation(sentence)
    result = len(sentence_no_punc.split())
    return result
    
test_sentence = "this is a  sentence, with 7 words."
word_count(test_sentence)
----

[source, Python]
----
7
----

Here, our helper function is named `\_strip_punctuation`. The preceding `_` is a hint to the programmer that the function is just for internal use (just for inside the function). If you try to call `\_strip_punctuation` outside of `word_count`, you will get an error. `_strip_punctuation` is defined within the scope of `word_count` and is not available outside that scope. In this example, `word_count` is the _caller_, the function that _calls_ the other function, `_strip_punctuation`. The other function, `_strip_punctuation`, can be referred to as the `callee`.

In `Python` functions can be passed to other functions as arguments. In general, functions that accept another function as an argument or return functions, are called higher order functions. Some examples of higher order functions in Python are `map`, `filter`, and `reduce`. The function passed as an argument, is often referred to as a _callback function_, as the _caller_ is expected to call back (execute) the argument at a later point in time.

== packing and unpacking

To pass any number of `n` arguments to a function, we can use argument tuple packing. For example:

[source, Python]
----
def sum_then_multiply_by_x(x = 0, *args):
    print(args)
    return sum(args)*x

print(sum_then_multiply_by_x(2, 1, 2, 3))
----

[source, Python]
----
(1, 2, 3)
12
----

[source, Python]
----
print(sum_then_multiply_by_x(2, 1, 2, 3, 4))
----

[source, Python]
----
(1, 2, 3, 4)
20
----

[source, Python]
----
print(sum_then_multiply_by_x(2, 1, 2, 3, 4, 5))
----

[source, Python]
----
(1, 2, 3, 4, 5)
30
----

Here, every argument passed after the `x` argument is _packed_ into a tuple called `args`. As you can see, you can pass any number of arguments.

Okay, great. Then what is argument tuple unpacking? Unpacking is the process of _unpacking_ a tuple containing many values to be passed as separate values to a function. For example:

[source, Python]
----
def print_foo_BAR(foo, bar):
    print(f'{foo}{bar.upper()}')
    
# normally we would call this function like so:
print_foo_BAR("first", "second")

# but, we can unpack a tuple of values to pass the arguments positionally
----

[source, Python]
----
firstSECOND
----

[source, Python]
----
my_tuple_to_unpack = ("first", "second")
print_foo_BAR(*my_tuple_to_unpack)
----

[source, Python]
----
firstSECOND
----

Just like we have tuple packing and unpacking for positional arguments, we have dict packing and unpacking for keyword arguments. For example:

[source, Python]
----
def print_arguments(**kwargs):
    for key, value in kwargs.items():
        print(f'key: {key}, value: {value}')

print_arguments(arg1="pretty", arg2="princess")
----

[source, Python]
----
key: arg1, value: pretty
key: arg2, value: princess
----

[source, Python]
----
print_arguments(arg1="pretty", arg2="pretty", arg3="princess")
----

[source, Python]
----
key: arg1, value: pretty
key: arg2, value: pretty
key: arg3, value: princess
----

Here, instead of `kwargs` being a tuple internally, it is a dict. Likewise, we have argument dictionary unpacking as well:

[source, Python]
----
def wild_animals(lions, tigers, bears):
    print(f'lions: {lions}')
    print(f'tigers: {tigers}')
    print(f'bears: {bears}')
    print('oh my!')
    
# normally we would call this function like so:
wild_animals(["bernice", "sandra", "arnold"], ["janice",], ('paul', 'jim', 'dwight'))

# but, we can unpack a tuple of values to pass the arguments positionally
----

[source, Python]
----
lions: ['bernice', 'sandra', 'arnold']
tigers: ['janice']
bears: ('paul', 'jim', 'dwight')
oh my!
----

[source, Python]
----
my_dict_to_unpack = {"lions":["bernice", "sandra", "arnold"], "tigers":["janice",], "bears":('paul', 'jim', 'dwight')}
wild_animals(**my_dict_to_unpack)
----

[source, Python]
----
lions: ['bernice', 'sandra', 'arnold']
tigers: ['janice']
bears: ('paul', 'jim', 'dwight')
oh my!
----

== arguments

When calling a function, arguments are not all the same. In Python, there are _positional_ and _keyword_ arguments. For example:

[source, Python]
----
def add_x_multiply_by_y(value: int, x: int, y: int) -> int:
    return (value+x)*y

add_x_multiply_by_y(2, 3, 4)
----

[source, Python]
----
20
----

Here, `2`, `3`, and `4` are positional arguments. It is using the order in which the arguments are passed in order to determine to which parameter the argument belongs. If we were to rearrange the order in which we passed our values, it would change the result:

[source, Python]
----
def add_x_multiply_by_y(value: int, x: int, y: int) -> int:
    return (value+x)*y

add_x_multiply_by_y(2, 4, 3)
----

[source, Python]
----
18
----

With that being said, we can use `keyword arguments` to specify where we are passing our values to. For example:

[source, Python]
----
def add_x_multiply_by_y(value: int, x: int, y: int) -> int:
    return (value+x)*y

add_x_multiply_by_y(2, y=4, x=3)
----

[source, Python]
----
20
----

Now, since we specified that we are passing `4` to `y`, we get the same result from our first example. Be careful when mixing and matching _keyword_ and _positional_ arguments. _Positional_ arguments _must_ come before keyword arguments. For example:

[source, Python]
----
# Error: positional argument follows keyword argument (<string>, line 5)
def add_x_multiply_by_y(value: int, x: int, y: int) -> int:
    return (value+x)*y

add_x_multiply_by_y(2, x=4, 3)
----

Just like in R, in Python, arguments can have default values. For example:

[source, Python]
----
def add_x_multiply_by_y(value: int, x: int, y: int = 5) -> int:
    return (value+x)*y

add_x_multiply_by_y(1, 2)
----

[source, Python]
----
15
----

Here, `1` is a positional argument for `value` and `2` is a positional argument for `x`. When not provided, `y` has a default value of `5`. Again, you must be careful when giving an argument a default value. You cannot have a non-default argument follow a default argument. For example:

[source, Python]
----
# Error: non-default argument follows default argument (<string>, line 1)
def add_x_multiply_by_y(value: int = 0, x: int, y: int) -> int:
    return (value+x)*y

add_x_multiply_by_y(x=1, y=3)
----

By default, you can pass arguments as either positional or keyword arguments. With that being said, if you want to, you )_can_ create arguments that are only positional or _only_ keyword. The way to specify an argument as _only_ keyword, is to use tuple packing _before_ a keyword argument. For example:

[source, Python]
----
def sum_then_multiply_by_x(*args, x) -> int:
    return sum(args)*x

sum_then_multiply_by_x(1,2,3,4, x=5)
----

[source, Python]
----
50
----

Here, if you were to try and run the following, it would fail:

[source, Python]
----
TypeError: sum_then_multiply_by_x() missing 1 required keyword-only argument: 'x'
sum_then_multiply_by_x(1,2,3,4,5)
----

This should make sense. We do not know how many arguments will be passed to `*args`. Therefore it is _required_ that any following arguments are _required_ to be keyword arguments, otherwise the function wouldn't know where `*args` stops and the next argument begins. You may then think, but can't we put the keyword argument before `*args` and then we know the first argument, `x`, is the first argument and the remaining arguments are `*args`? No, because then `x` could also be _positional_, then, and this would work.

[source, Python]
----
def sum_then_multiply_by_x(x, *args) -> int:
    return sum(args)*x

sum_then_multiply_by_x(1,2,3,4,5)
----

[source, Python]
----
14
----

To create one or more _positional_ only arguments, simply add a `/` as a standalone argument _after_ all of the arguments which you would like to be _only_ positional. For example:

[source, Python]
----
def sum_then_multiply_by_x(one, two, /, three, x) -> int:
    return sum([one, two, three])*x

sum_then_multiply_by_x(1,2,3,4) # all positional, will work
sum_then_multiply_by_x(1,2,three=3,x=4) # two keyword, two positional, will work
sum_then_multiply_by_x(1,two=2,three=3,x=4) # a positional only argument was passed as a keyword argument, error
----

== docstrings

docstrings are the strings inside the function immediately following the function declaration. docstrings provide documentation for the function. You can put any information you'd like in a docstring, however, it is best to carefully describe what the function does, and stay consistent in style from docstring to docstring.

You can access a function's docstring in various ways:

[source, Python]
----
print(word_count.__doc__)
----

[source, Python]
----
word_count is a function that accepts a sentence as an argument,
and returns the number of words in the sentence.
 
Args:
sentence (str): The sentence for which we are counting the words.
 
Returns:
int: The number of words in the sentence
 
----

[source, Python]
----
help(word_count)
----

[source, Python]
----
Help on function word_count in module __main__:
 
word_count(sentence: str) -> int
word_count is a function that accepts a sentence as an argument,
and returns the number of words in the sentence.
     
Args:
sentence (str): The sentence for which we are counting the words.
     
Returns:
int: The number of words in the sentence
----

In addition, if you are coding in a tool like VSCode, for example, you may gain the ability to hover over a function and see its docstring and other information.

It is good practice to write docstrings for every function you write.

== annotations

Another "thing" you may have noticed from our `word_count` function if you've ever used Python in the past. In the _signature_ of our function `def` `word_count(sentence: str) -> int`, we have some extra, _not_ required information in the form of _function annotations_. Specifically, you could write the `word_count` function like this, but it would function just the same:

[source, Python]
----
def word_count(sentence):
    """
    word_count is a function that accepts a sentence as an argument,
    and returns the number of words in the sentence.

    Args:
        sentence (str): The sentence for which we are counting the words.

    Returns:
        int: The number of words in the sentence
    """
    
    def _strip_punctuation(sentence: str):
        """
        helper function to strip punctuation.
        """
        return sentence.translate(str.maketrans('', '', string.punctuation))
    
    sentence_no_punc = _strip_punctuation(sentence)
    result = len(sentence_no_punc.split())
    return result
----

Here, we do not specify that `sentence` should be a `str` or that the returned result should be an `int`. When we _do_ annotate functions, it is purely a way to add metadata to our function. In large projects, function annotations are recommended. Although Python does not strictly enforce type annotations, packages like `mypy` can be added to a deployment scheme to strictly enforce it.

== decorators

=== Examples

*Write a function called get_filename_from_url that, given a url to a file, like https://image.shutterstock.com/image-vector/cute-dogs-line-art-border-260nw-1079902403.jpg returns the filename with the extension.*

[source, Python]
----
import os
from urllib.parse import urlparse

def get_filename_from_url(url: str) -> str:
    """
    Given a link to a file, return the filename with extension.

    Args:
        url (str): The url of the file.

    Returns:
        str: A string with the filename, including the file extension.
    """
    return os.path.basename(urlparse(url).path)
----

*Write a function that, given a url to an image, and a full path to a directory, saves the image to the provided directory. By default, have the function save the images to the user's home directory in a unix-like operating system.*

[source, Python]
----
import requests
from pathlib import Path
import getpass

def scrape_image(from_url: str, to_dir: str = f'/home/{getpass.getuser()}'):
    """
    Given a url to an image, scrape the image and save the image to the provided directory.
    If no directory is provided, by default, save to the user's home directory.

    Args:
        from_url (str): U
        to_dir (str, optional): [description]. Defaults to f'/home/{getpass.getuser()}'.
    """
    resp = requests.get(from_url)
    
    # this function is from the previous example
    filename = get_filename_from_url(from_url)
    
    # Make directory if doesn't already exist
    Path(to_dir).mkdir(parents=True, exist_ok=True)
    
    file = open(f'{to_dir}/{filename}', "wb")
    file.write(resp.content)
    file.close()
----