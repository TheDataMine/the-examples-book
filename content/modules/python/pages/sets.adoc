= Sets

== Introduction

To use a bad analogy, if a list is the popular kid in school, a set is their less popular friend that's worse at everything _except_ for chess, which they're very good at. Chess, in this case, is membership testing and handling duplicate entries.

In Python, lists and sets are both mutable. The key difference is that sets are _unordered_ and, as mentioned, you cannot have duplicate elements in a set. 

{sp}+

=== Implementation

Sets can be declared using the `set()` function or the curly braces `{}`. There are important differences here: `set()` only takes 0 or 1 argument(s), while `{}` is also the raw declaration of a dictionary variable, so creating an empty set can only be done with `set()`, while a set of 2 or more variables that doesn't already exist must be created with `{}`.

Below is a list of set functions https://www.w3schools.com/python/python_ref_set.asp[w3schools.com], some of which we discuss later.

|===
| Method | Alternative Code | Description

| `add()`
|
| Adds an element to a set

| `clear()`
|
| Removes all the elements from a set

| `copy()`
|
| Returns a copy of a set

| `difference(*other)`
| `this - other`
| Returns a (new) list of elements in this set that are not in the other. Can list multiple arguments in the function or `a - b - c` for subtraction.

| `difference_update(*other)`
|
| In-place version of `difference()`. Removes the shared item(s) from the original list. Cannot be called and printed simultaneously.

| `discard()` / `remove()`
| 
| Both functions remove the item from a set -- `remove()` will raise an error if the item is not in the set, `discard()` will not.

| `intersection(*other)`
| `this & other`
| Returns a set that includes the values that are in both sets.

| `intersection_update(*other)`
|
| In-place version of `intersection()`. Changes the original list to only include all the items shared between the set(s). Cannot be called and printed simultaneously.

| `isdisjoint(other)`
| 
| Compares exactly two sets. Returns `True` if there are no shared elements between the two, `False` otherwise.

| `issubset(other)`
| 
| Compares exactly two sets. Returns `True` if all the elements of this set are in the other set, `False` otherwise.

| `issuperset(other)`
| 
| Compares exactly two sets. Returns `True` if all the elements of the other set are included in the current one, `False` otherwise.

| `pop()`
| 
| Removes a random element from a set.

| `symmetric_difference(other)`
| 
| Compares exactly two sets. Returns a set that includes the items that are _not_ shared between sets.

| `symmetric_difference_update(other)`
| `this ^ other`
| In-place version of `symmetric_difference()`. Updates the current set to include all values that aren't shared between the sets.

| `union(*other)`
| `this \| other`
| Returns all the elements in all of the 2+ sets. Duplicates intrinsically disallowed.

| `update(*other)`
| 
| `other` is any iterable(s) to be added to the original set. Cannot be called & printed simultaneously.

|===

If you're adding value(s) to a set and run your code multiple times, you might notice that the order of the set differs if you print the final set. The disorder of the set manifests itself in this way -- the location of the item is determined by memory, which changes frequently. Instead of making sure the order of the set is correct, check using `==` as follows: 

[source,python]
----
fruits = {"apple", "banana", "strawberry"}
fruits2 = {"apple", "strawberry", "banana"}
print(fruits == fruits2)
----

----
True
----

The drawback here is that sets cannot be indexed like lists, so if you need to evaluate elements of your group at the item level instead of the group level, lists will better fit your needs.