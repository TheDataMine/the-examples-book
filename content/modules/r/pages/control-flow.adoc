= Control Flow

== If/else statements

If, else if, and else statements are methods for controlling whether or not an operation is performed based on the result of some expression.

=== Examples

==== How do I print "Success!" if my expression evaluates to `TRUE`, and "Failure!" otherwise?

.Click to see solution
[%collapsible]
====
[source, R]
----
# Randomly assign either TRUE or FALSE to t_or_f.
t_or_f <- sample(c(TRUE,FALSE),1)

if (t_or_f == TRUE) {
  # If t_or_f is TRUE, print success
  print("Success!")
} else {
  # Otherwise, print failure
  print("Failure!")
}
----

[source, R]
----
[1] "Failure!"
----

[source, R]
----
# You don't need to put the full expression.
# This is the same thing because t_or_f
# is already TRUE or FALSE. 
# TRUE == TRUE evaluates to TRUE and
# FALSE == TRUE evaluates to FALSE.
if (t_or_f) {
  # If t_or_f is TRUE, print success
  print("Success!")
} else {
  # Otherwise, print failure
  print("Failure!")
}
----

[source, R]
----
[1] "Failure!"
----
====

==== How do I print "Success!" if my expression evaluates to `TRUE`, "Failure!" if my expression evaluates to `FALSE`, and "Huh?" otherwise?

.Click to see solution
[%collapsible]
====
[source, R]
----
# Randomly assign either TRUE or FALSE to t_or_f.
t_or_f <- sample(c(TRUE,FALSE),1)

if (t_or_f == TRUE) {
  # If t_or_f is TRUE, print success
  print("Success!")
} else {
  # Otherwise, print failure
  print("Failure!")
}
## [1] "Failure!"
# You don't need to put the full expression.
# This is the same thing because t_or_f
# is already TRUE or FALSE. 
# TRUE == TRUE evaluates to TRUE and
# FALSE == TRUE evaluates to FALSE.
if (t_or_f) {
  # If t_or_f is TRUE, print success
  print("Success!")
} else {
  # Otherwise, print failure
  print("Failure!")
}
## [1] "Failure!"
How do I print "Success!" if my expression evaluates to TRUE, "Failure!" if my expression evaluates to FALSE, and "Huh?" otherwise?
Click here for solution
# Randomly assign either TRUE or FALSE to t_or_f.
t_or_f <- sample(c(TRUE,FALSE, "Something else"),1)

if (t_or_f == TRUE) {
  # If t_or_f is TRUE, print success
  print("Success!")
} else if (t_or_f == FALSE) {
  # If t_or_f is FALSE, print failure
  print("Failure!")
} else {
  # Otherwise print huh
  print("Huh?")
}
----

[source, R]
----
[1] "Failure!"
----

[source, R]
----
# In this case you need the full expression because
# "Something else" does not evaluate to TRUE or FALSE
# which will cause an error as the if and else if 
# statements expect a result of TRUE or FALSE.
if (t_or_f == TRUE) {
  # If t_or_f is TRUE, print success
  print("Success!")
} else if (t_or_f == FALSE) {
  # If t_or_f is FALSE, print failure
  print("Failure!")
} else {
  # Otherwise print huh
  print("Huh?")
}
----

[source, R]
----
[1] "Failure!"
----
====

== For loops

For loops allow us to execute similar code over and over again until we've looped through all of the elements. They are useful for performing the same operation to an entire vector of input, for example.

Using the suite of apply functions is more common in R. It is often said that the apply suite of function are much faster than for loops in R. While this used to be the case, this is no longer true.

=== Examples

==== How do I loop through every value in a vector and print the value?

.Click to see solution
[%collapsible]
====
[source, R]
----
for (i in 1:10) {
  # In the first iteration of the loop,
  # i will be 1. The next, i will be 2.
  # Etc.
  print(i)
}
----

[source, R]
----
[1] 1
[1] 2
[1] 3
[1] 4
[1] 5
[1] 6
[1] 7
[1] 8
[1] 9
[1] 10
----
====

==== How do I break out of a loop before it finishes?

.Click to see solution
[%collapsible]
====
[source, R]
----
for (i in 1:10) {
  if (i==7) {
    # When i==7, we will exit the loop.
    break
  }
  print(i)
}
----

[source, R]
----
[1] 1
[1] 2
[1] 3
[1] 4
[1] 5
[1] 6
----
====

==== How do I loop through a vector of names?

.Click to see solution
[%collapsible]
====
[source, R]
----
friends <- c("Phoebe", "Ross", "Rachel", "Chandler", "Joey", "Monica")
my_string <- "So no one told you life was gonna be this way, "
for (friend in friends) {
  print(paste0(my_string, friend, "!"))
}
----

[source, R]
----
[1] "So no one told you life was gonna be this way, Phoebe!"
[1] "So no one told you life was gonna be this way, Ross!"
[1] "So no one told you life was gonna be this way, Rachel!"
[1] "So no one told you life was gonna be this way, Chandler!"
[1] "So no one told you life was gonna be this way, Joey!"
[1] "So no one told you life was gonna be this way, Monica!"
----
====

==== How do I skip a loop if some expression evaluates to `TRUE`?

.Click to see solution
[%collapsible]
====
[source, R]
----
friends <- c("Phoebe", "Ross", "Mike", "Rachel", "Chandler", "Joey", "Monica")
my_string <- "So no one told you life was gonna be this way, "
for (friend in friends) {
  if (friend == "Mike") {
    # next, skips over the rest of the code for this loop
    # and continues to the next element
    next
  }
  print(paste0(my_string, friend, "!"))
}
----

[source, R]
----
[1] "So no one told you life was gonna be this way, Phoebe!"
[1] "So no one told you life was gonna be this way, Ross!"
[1] "So no one told you life was gonna be this way, Rachel!"
[1] "So no one told you life was gonna be this way, Chandler!"
[1] "So no one told you life was gonna be this way, Joey!"
[1] "So no one told you life was gonna be this way, Monica!"
----
====

==== Are there examples in which for loops are not appropriate to use?

.Click to see solution
[%collapsible]
====
This is usually how we write loops in other languages, e.g., C, C++, Java, Python, etc., if we want to add the first 10 billion integers.

[source, R]
----
mytotal <- 0
for (i in 1:10000000000) {
  mytotal <- mytotal + i
}
mytotal
----

[source, R]
----
[1] 5e+19
----

but this takes a long time to evaluate. It is easier to write, and much faster to evaluate, if we use the sum function, which is vectorized, i.e., which works on an entire vector of data all at once.

Here, for instance, we add the first 10 billion integers, and the computation occurs almost immediately.

[source, R]
----
sum(1:10000000000)
----

[source, R]
----
[1] 5e+19
----

https://cdnapisec.kaltura.com/html5/html5lib/v2.79.1/mwEmbedFrame.php/p/983291/uiconf_id/29134031/entry_id/1_1zf8kq5h?wid=_983291&iframeembed=true&playerId=kaltura_player&entry_id=1_1zf8kq5h&flashvars%5BstreamerType%5D=auto&flashvars%5BlocalizationCode%5D=en&flashvars%5BleadWithHTML5%5D=true&flashvars%5BsideBarContainer.plugin%5D=true&flashvars%5BsideBarContainer.position%5D=left&flashvars%5BsideBarContainer.clickToClose%5D=true&flashvars%5Bchapters.plugin%5D=true&flashvars%5Bchapters.layout%5D=vertical&flashvars%5Bchapters.thumbnailRotator%5D=false&flashvars%5BstreamSelector.plugin%5D=true&flashvars%5BEmbedPlayer.SpinnerTarget%5D=videoHolder&flashvars%5BdualScreen.plugin%5D=true&flashvars%5BKaltura.addCrossoriginToIframe%5D=true&&wid=1_agm08ttm[Video Explanation]
====

==== Can you show an example of how to do the same thing, with a for loop and without a for loop?

.Click to see solution
[%collapsible]
====
Yes, here is an example about how to compute the average cost of a line of the grocery store data.

[source, R]
----
myDF <- read.csv("/class/datamine/data/8451/The_Complete_Journey_2_Master/5000_transactions.csv")
head(myDF)
----

[source, R]
----
  BASKET_NUM HSHD_NUM PURCHASE_ PRODUCT_NUM SPEND UNITS STORE_R WEEK_NUM YEAR
1         24     1809 03-JAN-16     5817389 -1.50    -1   SOUTH        1 2016
2         24     1809 03-JAN-16     5829886 -1.50    -1   SOUTH        1 2016
3         34     1253 03-JAN-16      539501  2.19     1    EAST        1 2016
4         60     1595 03-JAN-16     5260099  0.99     1    WEST        1 2016
5         60     1595 03-JAN-16     4535660  2.50     2    WEST        1 2016
6        168     3393 03-JAN-16     5602916  4.50     1   SOUTH        1 2016
----

This is how we find the average cost per line in other languages, for instance, C/C++, Python, Java, etc.

[source, R]
----
amountspent <- 0       # we initialize a variable to keep track of the entire price of the purchases
numberofitems <- 0     # and we initialize a variable to keep track of the number of purchases
for (myprice in myDF$SPEND) {
  amountspent <- amountspent + myprice     # we add the price of the current purchase
  numberofitems <- numberofitems + 1       # and we increment (by 1) the number o purchases processed so far
}
amountspent     # this is the total amount spent on all purchases
----

[source, R]
----
[1] 3584366
----

[source, R]
----
numberofitems   # this is the total number of purchases
----

[source, R]
----
[1] 1e+06
----

[source, R]
----
amountspent/numberofitems       # so this is the average
----

[source, R]
----
[1] 3.584366
----

[source, R]
----
amountspent/length(myDF$SPEND)  # this is an equivalent way to compute the average
----

[source, R]
----
[1] 3.584366
----

For comparison, this is the much easier way that we can use a vectorized function in R, to accomplish the same purpose. The vector is the column myDF$SPEND. We can just focus our attention on that column from the data frame, and take a mean.

[source, R]
----
mean(myDF$SPEND)
----

[source, R]
----
[1] 3.584366
----

https://cdnapisec.kaltura.com/html5/html5lib/v2.79.1/mwEmbedFrame.php/p/983291/uiconf_id/29134031/entry_id/1_pz7cg2sc?wid=_983291&iframeembed=true&playerId=kaltura_player&entry_id=1_pz7cg2sc&flashvars%5BstreamerType%5D=auto&flashvars%5BlocalizationCode%5D=en&flashvars%5BleadWithHTML5%5D=true&flashvars%5BsideBarContainer.plugin%5D=true&flashvars%5BsideBarContainer.position%5D=left&flashvars%5BsideBarContainer.clickToClose%5D=true&flashvars%5Bchapters.plugin%5D=true&flashvars%5Bchapters.layout%5D=vertical&flashvars%5Bchapters.thumbnailRotator%5D=false&flashvars%5BstreamSelector.plugin%5D=true&flashvars%5BEmbedPlayer.SpinnerTarget%5D=videoHolder&flashvars%5BdualScreen.plugin%5D=true&flashvars%5BKaltura.addCrossoriginToIframe%5D=true&&wid=1_y3e1j45c[Video explanation]
====

==== Can you show an example of how to make a new column in a data frame, which classifies things, based on another column?

.Click to see solution
[%collapsible]
====
Yes, we can make a new column in the grocery store data set.

[source, R]
----
myDF <- read.csv("/class/datamine/data/8451/The_Complete_Journey_2_Master/5000_transactions.csv")
head(myDF)
----

[source, R]
----
  BASKET_NUM HSHD_NUM PURCHASE_ PRODUCT_NUM SPEND UNITS STORE_R WEEK_NUM YEAR
1         24     1809 03-JAN-16     5817389 -1.50    -1   SOUTH        1 2016
2         24     1809 03-JAN-16     5829886 -1.50    -1   SOUTH        1 2016
3         34     1253 03-JAN-16      539501  2.19     1    EAST        1 2016
4         60     1595 03-JAN-16     5260099  0.99     1    WEST        1 2016
5         60     1595 03-JAN-16     4535660  2.50     2    WEST        1 2016
6        168     3393 03-JAN-16     5602916  4.50     1   SOUTH        1 2016
----

Let's first make a new vector (the same length as a column of the data frame) in which all of the entries are safe.

[source, R]
----
mystatus <- rep("safe", times=nrow(myDF))
----

and then we can change the entries for the elements of `mystatus` that occurred on `05-JUL-16` or on `06-JUL-16` to be contaminated.

[source, R]
----
mystatus[(myDF$PURCHASE_ == "05-JUL-16")|(myDF$PURCHASE_ == "06-JUL-16")] <- "contaminated"
----

and finally change this into a factor, and add it as a new column in the data frame.

[source, R]
----
myDF$safetystatus <- factor(mystatus)
----

Now the head of the data frame looks like this:

[source, R]
----
head(myDF)
----

[source, R]
----
  BASKET_NUM HSHD_NUM PURCHASE_ PRODUCT_NUM SPEND UNITS STORE_R WEEK_NUM YEAR
1         24     1809 03-JAN-16     5817389 -1.50    -1   SOUTH        1 2016
2         24     1809 03-JAN-16     5829886 -1.50    -1   SOUTH        1 2016
3         34     1253 03-JAN-16      539501  2.19     1    EAST        1 2016
4         60     1595 03-JAN-16     5260099  0.99     1    WEST        1 2016
5         60     1595 03-JAN-16     4535660  2.50     2    WEST        1 2016
6        168     3393 03-JAN-16     5602916  4.50     1   SOUTH        1 2016
  safetystatus
1         safe
2         safe
3         safe
4         safe
5         safe
6         safe
----

and the number of contaminated rows versus safe rows is this:

[source, R]
----
table(myDF$safetystatus)
----

[source, R]
----

contaminated         safe 
        2459       997541
----

https://cdnapisec.kaltura.com/p/983291/sp/98329100/embedIframeJs/uiconf_id/29134031/partner_id/983291?iframeembed=true&playerId=kaltura_player&entry_id=1_fru4k006&flashvars%5BstreamerType%5D=auto&flashvars%5BlocalizationCode%5D=en&flashvars%5BleadWithHTML5%5D=true&flashvars%5BsideBarContainer.plugin%5D=true&flashvars%5BsideBarContainer.position%5D=left&flashvars%5BsideBarContainer.clickToClose%5D=true&flashvars%5Bchapters.plugin%5D=true&flashvars%5Bchapters.layout%5D=vertical&flashvars%5Bchapters.thumbnailRotator%5D=false&flashvars%5BstreamSelector.plugin%5D=true&flashvars%5BEmbedPlayer.SpinnerTarget%5D=videoHolder&flashvars%5BdualScreen.plugin%5D=true&flashvars%5BKaltura.addCrossoriginToIframe%5D=true&&wid=1_cxr17wtf[Video explanation]
====