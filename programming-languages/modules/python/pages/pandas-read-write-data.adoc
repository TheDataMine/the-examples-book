= Reading & writing data

== Reading data

The beginning step of most projects when using `pandas` is reading a file and storing it. The primary function we use is `read_csv`, which *reads* in *.csv* files and outputs a xref:pandas-dataframes[`DataFrame`]. Understanding a `DataFrame` isn't vital for this tutorial, just that `read_csv` outputs one.

As with any package, we must import `pandas`, and the customary import statement is `import pandas as pd`. Let's use `read_csv` to save the file "grades.csv" into the variable `myDF`:


[source, python]
----
import pandas as pd

myDF = pd.read_csv("grades.csv")
----

Cool! That was a lot of words to describe a very simple line of code. We can use the `head` function call to get a view of our `myDF` data.

[source,python]
----
myDF.head()
----
----
   grade       year
0    100     junior
1     99  sophomore
2     75  sophomore
3     74  sophomore
4     44     senior
----

[NOTE]
====
`read_csv` is not the only way to create a `DataFrame` -- recall that the function name is tied to the file type. 

".feather" and ".parquet" are two file types that make the storing and reading of `DataFrames` much more efficient, and can be read with `read_feather` and `read_parquet`, respectively.
====

{sp}+

=== `read_csv` Useful Parameters

Our function only needs a valid filename to operate, but it has dozens of optional parameters that change what it does.

`sep` is short for **sep**arator -- "csv" is an acronym for comma-separated values, and if you look at the raw text for a .csv file, you'll find all the values are indeed separated by commas. If your data entries are separated by tabs or semicolons, you'll have to clarify `sep="\t"` or `sep=";"` for your `DataFrame` to be correct.

`names`/`header` are complementary parameters that assign names to the columns of your `DataFrame`. If `names` is empty, then `header` takes the first row of the data as the column names; otherwise, `names` takes a list of _unique_ values to use as the column names.

`nrows` will select however many rows of data you want. The default is reading the whole file, but some datasets are so huge, limiting your data intake might be necessary.

`dtype` can be supplied with a *dictionary* of column-name:desired-data-type key/value pairs to replace `read_csv` default assignments for a column's type.

{sp}+

=== Examples

==== How do I read a .csv file called `grades_semi.csv` into a `pandas` DataFrame, where `grades_semi.csv` is semi-colon-separated instead of comma-separated?

.Click to see solution
[%collapsible]
====
[source, python]
----
import pandas as pd

myDF = pd.read_csv("./grades_semi.csv", sep=";")
myDF.head()
----

----
   grade       year
0    100     junior
1     99  sophomore
2     75  sophomore
3     74  sophomore
4     44     senior
----
====