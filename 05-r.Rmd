# R {#r}

## Getting started {#getting-started-with-r}

### Examples using the 84.51 data set. {#r-8451-intro}

Please see https://piazza.com/class/kdrxb6dxa8c6by?cid=110 for example code, to go along with this video.

**[Click here for video](https://cdnapisec.kaltura.com/p/983291/sp/98329100/embedIframeJs/uiconf_id/29134031/partner_id/983291?iframeembed=true&playerId=kaltura_player&entry_id=1_xqba3s8y&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=0_ew0xvcqy)**

Please see https://piazza.com/class/kdrxb6dxa8c6by?cid=110 for example code, to go along with this video.

We read in the data from the 8451 data set
(This is not the same data set from Project 2! It is only intended to give you an idea about how to use basic functions in R!)
The `read.csv` function is used to read in a data frame.
The variable `myDF` will be a data frame that stores the data.

```{r, eval=F}
myDF <- read.csv("/class/datamine/data/8451/The_Complete_Journey_2_Master/5000_transactions.csv")
```

```{r, echo=F}
myDF <- transactions_5000
```

Please give the data frame a minute or two, to load.  It is big!

The data frame has 10625553 rows and 9 columns:
```{r}
dim(myDF)
```

This is the data that describes the first 6 purchases:
```{r}
head(myDF)
```

Similarly, these are the amounts spent on the first 6 purchases.
We use the dollar sign to pull out a specific column of the data and focus (only) on that column.
```{r}
head(myDF$SPEND)
```

These first 6 values in the `SPEND` column add up to a total sum of 7.18 (you can check by hand if you like!)
```{r}
sum(head(myDF$SPEND))
```

The average of the first 6 values in the `SPEND` column is 1.196667
```{r}
mean(head(myDF$SPEND))
```

The first 100 values in the `SPEND` column are:
```{r}
head(myDF$SPEND, n=100)
```

Note that, in the line above, we have an "index" at the far left-hand side of the Console.  It shows the position of the first value on each line. The values will change, depending on how wide your screen is.

Here is the 1st value in the `SPEND` column:
```{r}
myDF$SPEND[1]
```

Here is the 22nd value in the `SPEND` column:
```{r}
myDF$SPEND[22]
```

Here is the 25th value in the `SPEND` column:
```{r}
myDF$SPEND[25]
```

Here are the last 20 values in the `SPEND` column.
(Notice that we changed `head` to `tail`, since `tail` refers to the end rather than the start.)
```{r}
tail(myDF$SPEND, n=20)
```

We can load the help menu for a function in `R` by using a question mark before the function name.
It takes some time to get familiar with the style of the `R` help menus, but once you get comfortable reading the help pages, they are very helpful indeed!
```{r}
?head
```

We already took an average of the first 6 entries in the `SPEND` column.
Now we can take an average of the entire `SPEND` column.
```{r}
mean(myDF$SPEND)
```

Again, here are the first six entries in the `SPEND` column.
```{r}
head(myDF$SPEND)
```

Suppose that we want to see which entires are bigger than 2 and which ones are smaller than 2.  Here are the first six results:
```{r}
head(myDF$SPEND > 2)
```

Now we can see what the actual values are.
Here are the first 100 such values that are each bigger than 2.
```{r}
head(myDF$SPEND[myDF$SPEND > 2], n=100)
```

You might want to plot the first 50 values in the `SPEND` column:
```{r}
plot(head(myDF$SPEND, n=50))
```

If the result says `Error in plot.new() : figure margins too large` then you just need to make your plotting window a little bigger, so that `R` has room to make the plot, and then run the line again.

There are 10625553 entries in the `SPEND` column:
```{r}
length(myDF$SPEND)
```

This makes sense, because the data frame has 10625553 rows and 9 columns.
```{r}
dim(myDF)
```

There are 6322739 entries larger than 2.
```{r}
length(myDF$SPEND[myDF$SPEND > 2])
```

There are 451155 entries larger than 10.
```{r}
length(myDF$SPEND[myDF$SPEND > 10])
```

There are 4197 entries less than -3.
```{r}
length(myDF$SPEND[myDF$SPEND <= -3])
```

We encourage you to play with the data sets, and to learn how to work with the data, by trying things yourself, and by asking questions.  We always welcome your questions, and we love for you to post questions on Piazza.
This is a great way for the entire community to learn together!

### Examples using the New York City yellow taxi cab data set.  {#r-nyc-taxi-intro}

Please see https://piazza.com/class/kdrxb6dxa8c6by?cid=110 for example code, to go along with this video.

**[Click here for video](https://cdnapisec.kaltura.com/p/983291/sp/98329100/embedIframeJs/uiconf_id/29134031/partner_id/983291?iframeembed=true&playerId=kaltura_player&entry_id=1_ryucs8fg&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=0_5n7pwhrx)**

This data set contains the information about the yellow taxi cab rides in New York City in June 2019.
```{r, eval=F}
myDF <- read.csv("/class/datamine/data/taxi/yellow/yellow_tripdata_2019-06.csv")
```

```{r, echo=F}
myDF <- taxi_201906
```

Here is the information about the first 6 taxi cab rides.
You need to imagine that your computer monitor is much, much wider than it actually is, so that your data has room to stretch out in 6 rows across your screen.  Instead, right now, the data wraps around, a few columns at a time.  This is probably obvious when you look at it.  Each column has a column header.
```{r}
head(myDF)
```

The `mean` cost (i.e., the average cost) of a taxi cab ride in New York City in June 2019 is 19.74, i.e., almost 20 dollars.
```{r}
mean(myDF$total_amount)
```

The `mean` number of passengers in a taxi cab ride is 1.567322.
```{r}
mean(myDF$passenger_count)
```

We can use the `table` function to tabulate the results of the number of taxi cab rides, according to the `passenger_count`

For instance, in this case,
there are 128130 taxi cab rides with 0 passengers,
there are 4854651 taxi cab rides with 1 passenger,
there are 1061648 taxi cab rides with 2 passengers, etc.
```{r}
table(myDF$passenger_count)
```

We can look at each `passenger_count` for which the `passenger_count` equals 4.
Of course, the results are all just the value 4!
```{r}
head(myDF$passenger_count[myDF$passenger_count == 4])
```

On a more interesting note, we can look at the total cost of a taxi cab ride with 4 passengers.
The first 6 rides that (each) have 4 passengers have these 6 costs:
```{r}
head(myDF$total_amount[myDF$passenger_count == 4])
```

The average cost of a taxi cab ride with 4 passengers is 20.42111, i.e., just a little more than 20 dollars.
```{r}
mean(myDF$total_amount[myDF$passenger_count == 4])
```

Altogether, our data set has 6941024 rows and 18 columns.
```{r}
dim(myDF)
```

For this reason, the `total_amount` column has 6941024 entries.
```{r}
length(myDF$total_amount)
```

The amounts of the first 6 taxi cab rides are:
```{r}
head(myDF$total_amount)
```

These are the amounts of the first 6 taxi cab rides that each cost more than 100 dollars.
```{r}
head(myDF$total_amount[myDF$total_amount > 100])
```

There are 16681 taxi cab rides that (each) cost more than 100 dollars.
```{r}
length(myDF$total_amount[myDF$total_amount > 100])
```

If we only include the taxi cab rides that (each) cost more than 100 dollars, the average number of passengers is 1.545051.
```{r}
mean(myDF$passenger_count[myDF$total_amount > 100])
```

There are 6941024 taxi cab rides altogether.
```{r}
length(myDF$passenger_count)
```

If we ask for the `length` of the taxi cab rides with `total_amount > 100`, we might expect to get a smaller number, but again we get 6941024.
```{r}
length(myDF$total_amount > 100)
```

This might be confusing at first, but we can look at the `head` of those results.
This is a vector of 6941024 occurrences of `TRUE` and `FALSE`, one per taxi cab ride.
```{r}
head(myDF$total_amount > 100)
```

The way to find out that there are only 16681 taxi cab rides that cost more than 100 dollars is (as we did before) to use the `TRUE` values as an index into another vector, like this:
```{r}
length(myDF$total_amount[myDF$total_amount > 100])
```

or like this
```{r}
sum(myDF$total_amount > 100)
```

In this latter method, we turn the `TRUE` values into 1's and the `FALSE` values into 0's (this happens automatically when we `sum` them up) and so we have 16681 values of 1's and the rest are 0's so the sum is 16681, just like we saw above.

## Variables {#r-variables}

### NA {#r-na}

NA stands for not available and, in general, represents a missing value or a lack of data.

#### How do I tell if a value is NA? {#r-isna}

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
# Test if value is NA.
value <- NA
is.na(value)

# Does is.nan return TRUE for NA?
is.nan(value)
```
</details>

### NaN {#r-nan}

NaN stands for not a number and, in general, is used for arithmetic purposes, for example, the result of 0/0.

#### How do I tell if a value is NaN?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
# Test if a value is NaN.
value <- NaN
is.nan(value)

value <- 0/0
is.nan(value)

# Does is.na return TRUE for NaN?
is.na(value)
```
</details>

### NULL {#r-null}

NULL represents the null object, and is often returned when we have undefined values. 

#### How do I tell if a value is NULL?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
# Test if a value is NaN.
value <- NULL
is.null(value)

class(value)

# Does is.na return TRUE for NULL?
is.na(value)
```

### Dates {#r-dates}

`Date` is a class which allows you to perform special operations like subtraction, where the number of days between dates are returned. Or addition, where you can add 30 to a `Date` and a `Date` is returned where the value is 30 days in the future.

You will usually need to specify the `format` argument based on the format of your date strings. For example, if you had a string `07/05/1990`, the format would be: `%m/%d/%Y`. If your string was `31-12-90`, the format would be `%d-%m-%y`. Replace `%d`, `%m`, `%Y`, and `%y` according to your date strings. A full list of formats can be found [here](https://www.stat.berkeley.edu/~s133/dates.html).

#### How do I convert a string "07/05/1990" to a `Date`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_string <- "07/05/1990"
my_date <- as.Date(my_string, format="%m/%d/%Y")
my_date
```
</details>

#### How do I convert a string "31-12-1990" to a `Date`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_string <- "31-12-1990"
my_date <- as.Date(my_string, format="%d-%m-%Y")
my_date
```
</details>

#### How do I convert a string "12-31-1990" to a `Date`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_string <- "12-31-1990"
my_date <- as.Date(my_string, format="%m-%d-%Y")
my_date
```
</details>

#### How do I convert a string "31121990" to a `Date`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_string <- "31121990"
my_date <- as.Date(my_string, format="%d%m%Y")
my_date
```
</details>

### Factors {#r-factors}

A `factor` is R's way of representing a categorical variable. There are entries in a factor (just like there are entries in a vector), but they are constrained to _only_ be chosen from a specific set of values, called the _levels_ of the factor.  They are useful when a vector has only a few different values it could be, like "Male" and "Female" or "A", "B", or "C".

#### How do I test whether or not a vector is a factor?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
test_factor <- factor("Male")
is.factor(test_factor)

test_factor_vec <- factor(c("Male", "Female", "Female"))
is.factor(test_factor_vec)
```
</details>

#### How do I convert a vector of strings to a factor?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- c("Male", "Female", "Female")
vec <- factor(c("Male", "Female", "Female"))
```
</details>

#### How do I get the unique values a factor could hold, also known as _levels_? {#r-levels}

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- factor(c("Male", "Female", "Female"))
levels(vec)
```
</details>

#### How can I rename the levels of a factor?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- factor(c("Male", "Female", "Female"))
levels(vec)
levels(vec) <- c("F", "M")
vec

# Be careful! Order matters, this is wrong:
vec <- factor(c("Male", "Female", "Female"))
levels(vec)
levels(vec) <- c("M", "F")
vec
```
</details>

#### How can I find the number of levels of a factor? {#r-nlevels}

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- factor(c("Male", "Female", "Female"))
nlevels(vec)
```
</details>

## Logical operators {#r-logical-operators}

Logical operators are symbols that can be used within R to compare values or vectors of values. 

Operator | Description
---------|------------
`<`      | less than
`<=`     | less than or equal to
`>`      | greater than
`>=`     | greater than or equal to
`==`     | equal to
`!=`     | not equal to
`!x`     | negation, not x
`x|y`    | x OR y
`x&y`    | x AND y

### Examples {#r-logical-operators-examples}

#### What are the values in a vector, `vec` that are greater than 5?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- 1:10
vec > 5
```
</details>

#### What are the values in a vector, `vec` that are greater than or equal to 5?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- 1:10
vec >= 5
```
</details>

#### What are the values in a vector, `vec` that are less than 5?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- 1:10
vec < 5
```
</details>

#### What are the values in a vector, `vec` that are less than or equal to 5?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- 1:10
vec <= 5
```
</details>

#### What are the values in a vector that are greater than 7 OR less than or equal to 2?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- 1:10
vec > 7 | vec <=2
```
</details>

#### What are the values in a vector that are greater than 3 AND less than 6?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- 1:10
vec > 3 & vec < 6
```
</details>

#### How do I get the values in `list1` that are in `list2`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
list1 <- c("this", "is", "a", "test")
list2 <- c("this", "a", "exam")
list1[list1 %in% list2]
```
</details>

#### How do I get the values in `list1` that are not in `list2`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
list1 <- c("this", "is", "a", "test")
list2 <- c("this", "a", "exam")
list1[!(list1 %in% list2)]
```
</details>

#### How can I get the number of values in a vector that are greater than 5?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- 1:10
sum(vec>5)

# Note, you do not need to do:
length(vec[vec>5])

# because TRUE==1 and FALSE==0 in R
TRUE==1
FALSE==0
```
</details>

### Resources 

**[Operators Summary](https://www.statmethods.net/management/operators.html)**

A quick list of the various operators with a few simple examples.

## Lists & Vectors {#r-lists-and-vectors}

A vector contains values that are all the same type. The following are some examples of vectors:

```{r}
# A logical vector
lvec <- c(F, T, TRUE, FALSE)
class(lvec)

# A numeric vector
nvec <- c(1,2,3,4)
class(nvec)

# A character vector
cvec <- c("this", "is", "a", "test")
class(cvec)
```
As soon as you try to mix and match types, elements are coerced to the simplest type required to represent all the data.

The order of representation is:

logical, numeric, character, list

For example:

```{r}
class(c(F, 1, 2))
class(c(F, 1, 2, "ok"))
class(c(F, 1, 2, "ok", list(1, 2, "ok")))
```

Lists are vectors that can contain any class of data. For example:

```{r}
list(TRUE, 1, 2, "OK", c(1,2,3))
```

With lists, there are 3 ways you can index.

```{r}
my_list <- list(TRUE, 1, 2, "OK", c(1,2,3), list("OK", 1,2, F))

# The first way is with single square brackets [].
# This will always return a list, even if the content 
# only has 1 component.
class(my_list[1:2])
class(my_list[3])

# The second way is with double brackets [[]].
# This will return the content itself. If the
# content is something other than a list it will
# return the value itself.
class(my_list[[1]])
class(my_list[[3]])

# Of course, if the value is a list itself, it will
# remain a list.
class(my_list[[6]])

# The third way is using $ to extract a single, named variable. 
# We need to add names first! $ is like the double bracket,
# in that it will return the simplest form.
my_list <- list(first=TRUE, second=1, third=2, fourth="OK", embedded_vector=c(1,2,3), embedded_list=list("OK", 1,2, F))
my_list$first
my_list$embedded_list
```

#### How do get the type of a vector? {#r-type}

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_vector <- c(0, 1, 2)
typeof(my_vector)
```
</details>

#### How do I convert a character vector to a numeric?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_character_vector <- c('1','2','3','4')
as.numeric(my_character_vector)
```
</details>

#### How do I convert a numeric vector to a character?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_numeric_vector <- c(1,2,3,4)
as.character(my_numeric_vector)
```
</details>

### Indexing {#r-indexing}

Indexing enables us to access a subset of the elements in vectors and lists. There are three types of indexing: positional/numeric, logical, and reference/named.

You can create a named vector and a named list easily:

```{r}
my_vec <- 1:5
names(my_vec) <- c("alpha","bravo","charlie","delta","echo")

my_list <- list(1,2,3,4,5)
names(my_list) <- c("alpha","bravo","charlie","delta","echo")

my_list2 <- list("alpha" = 1, "beta" = 2, "charlie" = 3, "delta" = 4, "echo" = 5)
```


```{r}
# Numeric (positional) indexing:
my_vec[1:2]
my_vec[c(1,3)]

my_list[1:2]
my_list[c(1,3)]
```

```{r}
# Logical indexing:
my_vec[c(T, F, T, F, F)]

my_list[c(T, F, T, F, F)]
```

```{r}
# Named (reference) indexing:
# if there are named values:
my_vec[c("alpha", "charlie")]

my_list[c("alpha", "charlie")]
```

#### Examples {#r-lists-vectors-indexing-examples}

##### How can I get the first 2 values of a vector named `my_vec`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_vec <- c(1, 13, 2, 9)
names(my_vec) <- c('cat', 'dog','snake', 'otter')
my_vec[1:2]
```
</details>


##### How can I get the values that are greater than 2?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_vec[my_vec>2]
```
</details>

##### How can I get the values greater than 5 and smaller than 10?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_vec[my_vec > 5 & my_vec < 10]
```
</details>


##### How can I get the values greater than 10 or smaller than 3?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_vec[my_vec > 10 | my_vec < 3]
```
</details>

##### How can I get the values for "otter" and "dog"?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_vec[c('otter','dog')]
```
</details>

### Recycling {#r-recycling}

Often operations in `R` on two or more vectors require them to be the same length. When `R` encounters vectors with different lengths, it automatically repeats (recycles) the shorter vector until the length of the vectors is the same.

### Examples {#r-lists-vectors-examples}

#### Given two numeric vectors with different lengths, add them element-wise.

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
x <- c(1,2,3)
y <- c(0,1)
x+y
```
</details>

## Basic R functions {#r-basic-functions}

### `all` {#r-all}

`all` returns a logical value (`TRUE` or `FALSE`) if all values in a vector are `TRUE`.

#### Examples {#r-basic-all-examples}

##### Are all values in `x` positive?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
x <- c(1, 2, 3, 4, 8, -1, 7, 3, 4, -2, 1, 3)
all(x>0) # FALSE
```
</details>

### `any` {#r-any}

`any` returns a logical value (`TRUE` or `FALSE`) if any values in a vector are `TRUE`.

#### Examples {#r-basic-any-examples}

##### Are any values in `x` positive?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
x <- c(1, 2, 3, 4, 8, -1, 7, 3, 4, -2, 1, 3)
any(x>0) # TRUE
```
</details>

### `all.equal` {#r-all.equal}

`all.equal` compares two objects and tests if they are "nearly equal" (up to some provided tolerance).

#### Examples {#r-basic-all.equal-examples}

##### Is $\pi$ equal to 3.14?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
all.equal(pi, 3.14) # FALSE
```
</details>

##### Is $\pi$ equal to 3.14 if our tolerance is 2 decimal cases?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
all.equal(pi, 3.14, tol=0.01) # TRUE
```
</details>

##### Are the vectors `x` and `y` equal?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
x <- 1:5
y <- c('1', '2', '3', '4', '5')
all.equal(x, y) # difference in type (numeric vs. character)
all.equal(x, as.numeric(y)) # TRUE
```
</details>

### `%in%` {#r-in}

Although `%in%` doesn't look like it, it is a function. Given two vectors, `%in%` returns a logical vector indicating if the respective values in the left operand have a match in the right operand. 

You can learn more about `%in%` by running `?"%in%"`. 

#### Examples {#r-basic-in-examples}

##### How do I find whether or not a value, `5` is in a given vector?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
5 %in% c(1,2,3)
5 %in% c(3,4,5)
```
</details>

##### How can I find which values in one vector are present in another?

<details>
    <summary>Click here for solution</summary>
```{r, eval=F}
c(1,2,3) %in% c(1,2)
```
```{r, eval=F}
c(1,2,3) %in% c(3,4,5)
# order doesn't matter for the right operand
c(1,2,3) %in% c(5,3,4)
```
</details>

### `setdiff` {#r-setdiff}

Given two vectors, the function `setdiff` returns the element of the first vector which do not exist in the second vector. 
**Note:** The order in which the vectors are listed in relation to the function `setdiff` matters, as illustrated in the first two examples.


#### Examples {#r-basic-setdiff-examples}

##### Let `x = (a, b, b, c)` and `y = (c, b, d, e, f)`. How to I find the elements in vector `x` that are not in vector `y`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
x <- c('a','b','b','c')
y <- c('c','b','d','e','f')
setdiff(x,y)
setdiff(y,x)
```
</details>

##### How to I find the elements in vector `y` that are not in vector `x`?
<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
x <- c('a','b','b','c')
y <- c('c','b','d','e','f')
setdiff(y,x)
```
</details>

### `intersect` {#r-intersect}

The `intersect` function returns the elements that two vectors or data.frames have in common. 

**Note:** The order in which the vectors are listed in relation to the function `intersect` only affects the order of the common elements returned.


#### Examples {#r-basic-intersect-examples}

##### Let `x = (a, b, b, c)` and `y = (c, b, d, e, f)`. How to I find the elements shared both by vector `x` and by vector `y`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
x <- c('a','b','b','c')
y <- c('c','b','d','e','f')
intersect(x,y)

# as you can see, reversing the order
# of the arguments only changes the order
# in which the results are in the returned vector
intersect(y,x)
```
</details>

### `dim` {#r-dim}

`dim` returns the dimensions of a matrix or data.frame. The first value is the rows, the second is columns.

#### Examples {#r-basic-dim-examples}

##### How many dimensions does the data.frame `dat` have?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
dat <- data.frame("col1"=c(1,2,3), "col2"=c("a", "b", "c"))
dim(dat) # 3 rows and 2 columns
```
</details>

### `length` {#r-length}

`length` allows you to get or set the length of an object in R (for which a method has been defined).

#### How do I get how many values are in a vector?
<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
# Create a vector of length 5
my_vector <- c(1,2,3,4,5)

# Calculate the length of my_vector
length(my_vector)
```
</details>

### `rep` {#r-rep}

`rep` is short for replicate. `rep` accepts some object, `x`, and up to three additional arguments: `times`, `length.out`, and `each`. `times` is the number of non-negative _times_ to repeat the whole object `x`. `length.out` specifies the end length you want the result to be. `rep` will repeat the values in `x` as many times as it takes to reach the provided `length.out`. `each` repeats each element in `x` the number of times specified by `each`.

#### Examples {#r-basic-rep-examples}

##### How do I repeat values in a vector 3 times?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- c(1,2,3)
rep(vec, 3)

# or

rep(vec, times=3)
```
</details>

##### How do I repeat the values in a vector enough times to be the same length as another vector?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- c(1,2,3)
other_vec <- c(1,2,2,2,2,2,2,8)
rep(vec, length.out=length(other_vec))

# Note that if the end goal is to do something 
# like add the two vectors, this can be done
# using recycling.
rep(vec, length.out=length(other_vec)) + other_vec

vec + other_vec
```
</details>

##### How can I repeat each value inside a vector a certain amount of times?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- c(1,2,3)
rep(vec, each=3)
```
</details>

##### How can I repeat the values in one vector based on the values in another vector?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- c(1,2,3)
rep_by <- c(3,2,1)
rep(vec, times=rep_by)
```
</details>

### `rbind` and `cbind` {#r-bind}

`rbind` and `cbind` append objects (vectors, matrices or data.frames) as rows (`rbind`) or as columns (`cbind`).

#### Examples {#r-basic-rbind-cbind-examples}

##### How do I combine 3 vectors into a matrix?
<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
x <- 1:10
y <- 11:20
z <- 10:1

# combining them as rows
rbind(x,y,z)
dim(rbind(x,y,z))

# combining them as columns
cbind(x,y,z)
dim(cbind(x,y,z))
```
</details>

##### How do I add a vector as a column to a matrix?
<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
x <- 1:10
my_mat <- matrix(1:20, ncol=2)

my_mat <- cbind(my_mat, x)
dim(my_mat)
```
</details>

##### How do I append new rows to a matrix?
<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_mat1 <- matrix(20:1, ncol=2)
my_mat2 <- matrix(1:20, ncol=2)

my_mat <- rbind(my_mat1, my_mat2)
dim(my_mat)
```
</details>

### `which`, `which.max`, `which.min` {#r-which}

`which` enables you to find the position of the elements that are `TRUE` in a logical vector.

`which.max` and `which.min` finds the location of the maximum and minimum, respectively, of a numeric (or logical) vector. 

#### Examples {#r-basic-which-examples}

##### Given a numeric vector, return the index of the maximum value. {#r-max}
<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
x <- c(1,-10, 2,4,-3,9,2,-2,4,8)
which.max(x)

# which.max is just shorthand for:
which(x==max(x))
```
</details>

##### Given a vector, return the index of the positive values.
<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
x <- c(1,-10, 2,4,-3,9,2,-2,4,8)
which(x>0)
```
</details>

##### Given a matrix, return the indexes (row and column) of the positive values.
<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
x <- matrix(c(1,-10, 2,4,-3,9,2,-2,4,8), ncol=2)
which(x>0, arr.ind = TRUE)
```
</details>

### `grep`, `grepl`, etc. {#r-grep}

`grep` allows you to use regular expressions to search for a pattern in a string or character vector, and returns the index where there is a match.

`grepl` performs the same operation but rather than returning indices, returns a vector of logical `TRUE` or `FALSE` values.

#### Examples {#r-basic-grep-examples}

##### Given a character vector, return the index of any words ending in "s".
<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
grep(".*s$", c("waffle", "waffles", "pancake", "pancakes"))
```
</details>

##### Given a character vector, return a vector of the same length where each element is `TRUE` if there was a match for any word ending in "s", and `FALSE otherwise.
<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
grepl(".*s$", c("waffle", "waffles", "pancake", "pancakes"))
```
</details>

#### Resources {#r-grep-resources}

**[ReExCheatsheet](https://rstudio.com/wp-content/uploads/2016/09/RegExCheatsheet.pdf)**

An excellent quick reference for regular expressions. Examples using `grep` in R.

### `sum` {#r-sum}

`sum` is a function that calculates the sum of a vector of values.

#### Examples {#r-basic-sum-examples}

#### How do I get the sum of the values in a vector?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
sum(c(1,3,2,10,4))
```
</details>

#### How do I get the sum of the values in a vector when some of the values are: `NA`, `NaN`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
sum(c(1,2,3,NaN), na.rm=T)

sum(c(1,2,3,NA), na.rm=T)

sum(c(1,2,NA,NaN,4), na.rm=T)
```
</details>

### `mean` {#r-mean}

`mean` is a function that calculates the average of a vector of values.

#### How do I get the average of a vector of values?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
mean(c(1,2,3,4))
```
</details>

#### How do I get the average of a vector of values when some of the values are: `NA`, `NaN`?

<details>
    <summary>Click here for solution</summary>
    
Many R functions have the `na.rm` argument available. This argument is "a logical value indicating whether NA values should be stripped before the computation proceeds." 

```{r, eval=T}
mean(c(1,2,3,NaN), na.rm=T)

mean(c(1,2,3,NA), na.rm=T)

mean(c(1,2,NA,NaN,4), na.rm=T)
```
</details>

### `var` {#r-var}

`var` is a function that calculate the variance of a vector of values.

#### How do I get the variance of a vector of values?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
var(c(1,2,3,4))
```
</details>

#### How do I get the variance of a vector of values when some of the values are: `NA`, `NaN`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
var(c(1,2,3,NaN), na.rm=T)

var(c(1,2,3,NA), na.rm=T)

var(c(1,2,NA,NaN,4), na.rm=T)
```
</details>

#### How do I get the standard deviation of a vector of values?

<details>
    <summary>Click here for solution</summary>
    
The standard deviation is equal to the square root of the variance.

```{r, eval=T}
sqrt(var(c(1,2,3,NaN), na.rm=T))

sqrt(var(c(1,2,3,NA), na.rm=T))

sqrt(var(c(1,2,NA,NaN,4), na.rm=T))
```
</details>

### `colSums` and `rowSums` {#r-sums}

`colSums` and `rowSums` calculates row and column sums for numeric matrices or data.frames. 

#### Examples {#r-basic-colsums-examples}

#### How do I get the sum of the values for every column in a data frame?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
# First 6 values in mtcars
head(mtcars)
# For every column, sum of all rows:
colSums(mtcars)
```
</details>

#### How do I get the sum of the values for every row in a data frame?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
# First 6 values in mtcars
head(mtcars)
# For every row, sum of all columns:
rowSums(mtcars)
```

### `colMeans` and `rowMeans` {#r-means}

`colMeans` and `rowMeans` calculates row and column means for numeric matrices or data.frames. 

#### Examples {#r-basic-colmeans-examples}

#### How do I get the mean for every column in a data frame?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
# First 6 values in mtcars
head(mtcars)
# Mean of each column
colMeans(mtcars)
```
</details>

#### How do I get the mean for every row in a data frame?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
# First 6 values in mtcars
head(mtcars)
# Mean of each row
rowMeans(mtcars)
```

### `unique` {#r-unique}

`unique` "returns a vector, data frame, or array like x but with duplicate elements/rows removed.

#### Given a vector of values, how do I return a vector of values with all duplicates removed?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vec <- c(1, 2, 3, 3, 3, 4, 5, 5, 6)
unique(vec)
```
</details>

### `summary` {#r-summary}

`summary` shows summary statistics for a vector, or for every column in a data.frame and/or matrix. The summary statistics shown are: mininum value, maximum value, first and third quartiles, mean and median.

#### Examples {#r-basic-summary-examples}

#### How do I get summary statistics for a vector?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
summary(1:30)
```
</details>

#### How do I get summary statistics for every column in a data frame?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
# First 6 values in mtcars
head(mtcars)
# Mean of each column
summary(mtcars)
```
</details>



### `order` and `sort` {#r-order}

`sort` allows you to arrange (or partially arrange) a vector into ascending or descending order.

`order` returns the position of each element of a vector in ascending (or descending order).

#### Examples {#r-basic-order-sort-examples}

##### Given a vector, arrange it in a ascending order.

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
x <- c(1,3,2,10,4)
sort(x)
```
</details>

##### Given a vector, arrange it in a descending order.

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
x <- c(1,3,2,10,4)
sort(x, decreasing = TRUE)
```
</details>

##### Given a character vector, arrange it in ascending order.

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
sort(c("waffle", "pancake", "eggs", "bacon"))
```
</details>

##### Given a matrix, arrange it in ascending order using the first column.

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_mat <- matrix(c(1,5,0, 2, 10, 1, 2, 8, 9, 1,0,2), ncol=3)
my_mat[order(my_mat[,1]),]
```
</details>

### `paste` and `paste0` {#r-paste}

`paste` is a useful function to "concatenate vectors after converting to character."

`paste0` is a shorthand function where the `sep` argument is "".

#### How do I concatenate two vectors, element-wise, with a comma in between values from each vector?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
vector1 <- c("one", "three", "five")
vector2 <- c("two", "four", "six")
paste(vector1, vector2, sep=",")
```
</details>

#### How do I paste together two strings?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
paste0("abra", "kadabra")
```
</details>

#### How do I paste together three strings?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
paste0("abra", "kadabra", "alakazam")
```
</details>

### `head` and `tail` {#r-head}

`head` returns the first `n` (default is 6) parts of a vector, matrix, table, data.frame or function. For vectors, `head` shows the first 6 values, for matrices, tables and data.frame, `head` shows the first 6 rows, and for functions the first 6 rows of code.

`tail` returns the last `n` (default is 6) parts of a vector, matrix, table, data.frame or function. 

#### Examples {#r-basic-head-tail-examples}

##### How do I get the first 6 rows of a data.frame?

<details>
    <summary>Click here for solution</summary>
```{r}
head(df)
```
</details>

##### How do I get the first 10 rows of a data.frame?

<details>
    <summary>Click here for solution</summary>
```{r}
head(df, 10)
```
</details>

##### How do I get the last 6 rows of a data.frame?

<details>
    <summary>Click here for solution</summary>
```{r}
tail(df)
```
</details>

##### How do I get the last 8 rows of a data.frame?

<details>
    <summary>Click here for solution</summary>
```{r}
tail(df, 8)
```
</details>


### `str` {#r-str}

`str` stands for _structure_. `str` gives you a glimpse at the variable of interest. 

```{r, include=F}
df <- flights_sample
```

#### Examples {#r-basic-str-examples}

##### How do I get the number of columns or features in a data.frame?

<details>
    <summary>Click here for solution</summary>
    
As you can see, there are 9 rows or obs. (short for observations), and 29 variables (which can be referred to as columns or features).
```{r, eval=F}
str(df)
```
</details>

### `strsplit` {#r-strsplit}

`strsplit` accepts a vector of strings, and a vector of strings representing regular expressions. Each string in the first vector is split according to the respective string in the second vector. 

#### Examples {#r-basic-strsplit-examples}

##### How do I split a string containing multiple sentences into individual sentences?

<details>
    <summary>Click here for solution</summary>
    
Note that you need to [escape](#faq-escape-characters) the "." as "." means "any character" in regular expressions. In R, you put two "\" before it.
```{r, eval=T}
multiple_sentences <- "This is the first sentence. This is the second sentence. This is the third sentence."
unlist(strsplit(multiple_sentences, "\\."))

# remove extra whitespace
trimws(unlist(strsplit(multiple_sentences, "\\.")))
```
</details>

##### How do I split one string by a space, and the next string by a "."?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
string_vec <- c("Okay okay you win.", "This. Is. Not. Okay.")
strsplit(string_vec, c(" ", "\\."))
```
</details>

### `names` {#r-names}

`names` is a function that returns the names of a an object. This includes the typical data structures: vectors, lists, and data.frames. By default, `names` will return the column names of a data.frame, not the row names.

```{r, include=F}
df <- data.frame(cat_1=c(1,2,3), cat_2=c(9,8,7), ok=c(T, T, F), other=c("first", "second", "third"))
```

#### Examples {#r-basic-names-examples}

##### How do I get the column names of a data.frame?

<details>
    <summary>Click here for solution</summary>
```{r}
# Get the column names of a data.frame
names(df)
```
</details>

##### How do I get the names of a list?

<details>
    <summary>Click here for solution</summary>
```{r}
# Get the names of a list
names(list(col1=c(1,2,3), col2=c(987)))
```
</details>

##### How do I get the names of a vector?

<details>
    <summary>Click here for solution</summary>
```{r}
# Get the names of a vector
names(c(val1=1, val2=2, val3=3))
```
</details>

##### How do I change the column names of a data.frame?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
names(df) <- c("col1", "col2", "col3", "col4")
df
```
</details>


### `colnames` & `rownames` {#r-colnames-and-rownames}

`colnames` is the same as `names` but specifies the column names. `rownames` is the same as `names` but specifies the row names.

### `table` & `prop.table` {#r-table}

`table` is a function used to build a [contingency table](https://en.wikipedia.org/wiki/Contingency_table) of counts of various factors.

`prop.table` is a function that accepts the output of `table` and rather than returning counts, returns conditional proportions.

#### Examples {#r-basic-table-examples}

```{r, include=F}
grades <- grades
grades$sex <- factor(rep(c("M", "F", "M", "M", "F"), 2))
```

##### How do I get a count of the number of students in each year in our `grades` data.frame?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
table(grades$year)
```
</details>

##### How do I get the precentages of students in each year in our `grades` data.frame?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
prop.table(table(grades$year))
```
</details>

##### How do I get a count of the number of students in each year by sex in our `grades` data.frame?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
table(grades$year, grades$sex)
```
</details>

##### How do I get the precentages of students in each year by sex in our `grades` data.frame?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
prop.table(table(grades$year, grades$sex))
```
</details>

### `cut` {#r-cut}

`cut` breaks a vector `x` into factors specified by the argument `breaks`. `cut` is particularly useful to break Date data into categories like "Q1", "Q2", or 1998, 1999, 2000, etc.

You can find more useful information by running `?cut.POSIXt`.

#### Examples {#r-basic-cut-examples}

```{r, include=F}
times <- seq(as.POSIXct("2020-06-01 06:00"), by = "1 month", length.out = 24)
# times <- aggregate(1:24, list(day = cut(times, "days")), mean)
df <- data.frame(times=times)
df$value <- sample(1:100, size=length(df$times))
```

##### How can I create a new column in a data.frame `df` that is a factor based on the year?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
df$year <- cut(df$times, breaks="year")
str(df)
```
</details>

##### How can I create a new column in a data.frame `df` that is a factor based on the quarter?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
df$quarter <- cut(df$times, breaks="quarter")
str(df)
```
</details>

##### How can I create a new column in a data.frame `df` that is a factor based on every 2 weeks?

```{r, include=F}
times <- seq(as.POSIXct("2020-06-01 06:00"), by = "1 day", length.out = 45)
# times <- aggregate(1:24, list(day = cut(times, "days")), mean)
df <- data.frame(times=times)
df$value <- sample(1:100, size=length(df$times))
```

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
df$biweekly <- cut(df$times, breaks="2 weeks")
```
</details>


For an example with the 7581 data set:
```{r, eval=F}
myDF <- read.csv("/class/datamine/data/fars/7581.csv")
```

These are the values of the `HOUR` column:
```{r, eval=F}
table(myDF$HOUR)
```

We can break these values into 6-hour intervals:
```{r, eval=F}
table( cut(myDF$HOUR, breaks=c(0,6,12,18,24,99), include.lowest=T) )
```

and then find the total number of `PERSONS` who are involved in accidents during each 6-hour interval
```{r, eval=F}
tapply( myDF$PERSONS, cut(myDF$HOUR, breaks=c(0,6,12,18,24,99), include.lowest=T), sum )
```

**[Click here for video](https://cdnapisec.kaltura.com/p/983291/sp/98329100/embedIframeJs/uiconf_id/29134031/partner_id/983291?iframeembed=true&playerId=kaltura_player&entry_id=1_pjbc24vt&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_5fxuybgb)**

### `subset` {#r-subset}

`subset` is a function that helps you take subsets of data. By default, subset removes NA rows, so use with care. `subset` does not perform any operation that can't be accomplished by indexing, but can sometimes be easier to read.

Where we would normally write something like:

```{r}
grades[grades$year=="junior" | grades$sex=="M",]$grade
```

We can instead do:

```{r}
subset(grades, year=="junior" | sex=="M", select=grade)
```

But be careful, if we replace a grade with an NA, it will be removed by subset:

```{r}
grades$sex[8] <- NA
subset(grades, year=="junior" | sex=="M", select=grade)
```

Whereas indexing will not unless you specify to:

```{r}
grades[grades$year=="junior" | grades$sex=="M",]$grade
```

#### How can I easily make a subset of the 8451 data, using only 1 line of R, with the `subset` function? {#r-subset-8451-example}

**[Click here for video](https://cdnapisec.kaltura.com/p/983291/sp/98329100/embedIframeJs/uiconf_id/29134031/partner_id/983291?iframeembed=true&playerId=kaltura_player&entry_id=1_2gzdeg6h&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_sqr78rpp)**

In the 84.51 data set:

```{r, eval=F}
myDF <- read.csv("/class/datamine/data/8451/The_Complete_Journey_2_Master/5000_transactions.csv")
```

We recall that these are the variables:

```{r, eval=F}
head(myDF)
```
and there are 10625553 rows and 9 columns
```{r, eval=F}
dim(myDF)
```

We can use the `subset` command to focus on only the purchases from the `CENTRAL` store region, in the `YEAR` 2016.  We can also pick which variables that we want to have in this new data frame.

Please note:  We do not need to specify `myDF` on each variable, because the `subset` function will keep track of this for us. The `subset` function knows which data set that we are working with, because we specify it as the first parameter in the `subset` function.

The `subset` parameter of the `subset` function describes the rows that we are interested in.  (In particular, we specify the conditions that we want the rows to satisfy.)

The `select` parameter of the `subset` function describes the columns that we are interested in.  (We list the columns by their names, and we need to put each such column name in double quotes.)

```{r, eval=F}
myfocusedDF <- subset(myDF, subset=(STORE_R=="CENTRAL") & (YEAR==2016),
                            select=c("PURCHASE_","PRODUCT_NUM","SPEND","UNITS") )
```
This new data set has only 1246144 rows, i.e., about 12 percent of the purchases, as expected.  It also has only the 4 columns that we specified in the `subset` function.
```{r, eval=F}
dim(myfocusedDF)
```


#### How can I easily make a subset of the election data, using only 1 line of R, with the `subset` function? {#r-subset-election-example}

**[Click here for video](https://cdnapisec.kaltura.com/p/983291/sp/98329100/embedIframeJs/uiconf_id/29134031/partner_id/983291?iframeembed=true&playerId=kaltura_player&entry_id=1_0y3s42ph&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_6u16p3ir)**

Here is an example of how to use the `subset` function with the data from the federal election campaign contributions from 2016:

```{r, eval=F}
library(data.table)
myDF <- fread("/class/datamine/data/election/itcont2016.txt", sep="|")
```

There were 20557796 donations made in 2016:

```{r, eval=F}
dim(myDF)
```

We can use the `subset` command to focus on the donations made from Midwest states, and limit our results to those donations that had positive `TRANSACTION_AMT` values.  We can extract interesting variables, e.g., the `NAME`, `CITY`, `STATE`, and `TRANSACTION_AMT`.
```{r, eval=F}
mymidwestDF <- subset(myDF, subset=(STATE %in% c("IN","IL","OH","MI","WI")) & (TRANSACTION_AMT > 0),
                      select=c("NAME","CITY","STATE","TRANSACTION_AMT") )
```

The resulting data frame has 2435825 rows.
```{r, eval=F}
dim(mymidwestDF)
```

From the data set, we can `sum` the `TRANSACTION_AMT` values, grouped according to the `NAME` of the donor, and we find that `EYCHANER, FRED` was the top donor living in the midwest, during the 2016 federal election campaigns.
```{r, eval=F}
tail(sort(tapply(mymidwestDF$TRANSACTION_AMT, mymidwestDF$NAME, sum)))
```
### `difftime` {r#-difftime}

The function `difftime` computes/creates a time interval between two dates/times and converts the interval to a chosen time unit.

#### Examples {#r-basic-difftime-examples}

##### How many days,hours and minutes are there between the dates `2015-04-06` and `2015-01-01`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=F}
# number of days 
difftime(ymd("2015-04-06"),ymd("2015-01-01"), units="days")

# number of hours
difftime(ymd("2015-04-06"),ymd("2015-01-01"), units="hours")

# number of minutes 
difftime(ymd("2015-04-06"),ymd("2015-01-01"), units="mins")
```
</details>

### `merge` {#r-merge}

`merge` is a function that can be used to combine data.frames by row names, or more commonly, by column names. `merge` can replicate the join operations in SQL. The documentation is quite clear, and a useful resource: `?merge`.

#### How can I easily merge the `fars` data with the `state_names` data, using only 1 line of R, with the `merge` function? {#r-merge-fars-example}

**[Click here for video](https://cdnapisec.kaltura.com/p/983291/sp/98329100/embedIframeJs/uiconf_id/29134031/partner_id/983291?iframeembed=true&playerId=kaltura_player&entry_id=1_bxka9wh8&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_o2rh94x8)**

In STAT 19000, Project 6, we used the `state_names` data frame, to change the codes for the State's names into the State's actual names.  We gave you the code to do so (in Question 1 of Project 6).

It is easier, however, to use the `merge` function.

```{r, eval=F}
dat <- read.csv("/class/datamine/data/fars/7581.csv")
state_names <- read.csv("/class/datamine/data/fars/states.csv")
```

We look at the heads of both data frames.
```{r, eval=F}
head(dat)
head(state_names)
```
The `STATE` column of the `dat` data frame corresponds to the `code` column of the `state_names` data frame.

Now we merge these two data frames, by corresponding values from this column.

We call resulting data frame `mynewDF`
```{r, eval=F}
mynewDF <- merge(dat,state_names,by.x="STATE",by.y="code")
```

The new column, called `state` (not to be confused with `STATE`) is the rightmost column in this new data frame.
```{r, eval=F}
head(mynewDF)
```

Now we can solve Project 6, Question 2, using this new data frame.
```{r, eval=F}
sort(tapply(mynewDF$DRUNK_DR, mynewDF$state, mean))
```

#### How can I easily merge the data about flights with the data about the airports themselves, using only 1 line of R, with the `merge` function? {#r-merge-flights-example}

**[Click here for video](https://cdnapisec.kaltura.com/p/983291/sp/98329100/embedIframeJs/uiconf_id/29134031/partner_id/983291?iframeembed=true&playerId=kaltura_player&entry_id=1_he3leb19&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_1zxh0xw1)**

Here is the flight data from 1995.

Notice that, for instance, the locations of the airports are not given.

We only know the airport `Origin` and `Dest` codes.

```{r, eval=F}
myDF <- read.csv("/class/datamine/data/flights/subset/1995.csv")
```

Here is a listing of the information about the airports themselves:
```{r, eval=F}
airportsDF <- read.csv("/class/datamine/data/flights/subset/airports.csv")
```

We see that the 3-letter codes about the airports are given in the `Origin` and `Dest` columns of `myDF`.
```{r, eval=F}
head(myDF)
```

It is harder to tell which column in the `airportsDF` gives the 3-letter codes, but these are the `iata` codes
```{r, eval=F}
head(airportsDF)
```

It is perhaps easier to see this from the tale of `airportsDF`:
```{r, eval=F}
tail(airportsDF)
```

Now we merge the two data frames, and we display the information about the `Origin` airport, by linking the `Origin` column of `myDF` with the `iata` column of `airportsDF`:
```{r, eval=F}
mynewDF <- merge(myDF, airportsDF, by.x="Origin", by.y="iata")
```

The resulting data frame has the same size as `myDF`:
```{r, eval=F}
dim(myDF)
dim(mynewDF)
```
but now has extra columns, namely, with information about the `Origin` airport:
```{r, eval=F}
head(mynewDF)
tail(mynewDF)
```

So now we can do things like calculating a `sum` of all `Distance`s of flights with `Origin` in each `state`:
```{r, eval=F}
sort(tapply( mynewDF$Distance, mynewDF$state, sum ))
```




#### Here is another `merge` example:

```{r, include=F}
books <- data.frame(
  id = 1:10,
  title = c("Harry Potter and the Sorcerer's Stone", "Harry Potter and the Chamber of Secrets", "Harry Potter and the Prisoner of Azkaban", "Harry Potter and the Goblet of Fire", "Harry Potter and the Order of the Phoenix", "Harry Potter and the Half Blood Prince", "Harry Potter and the Deathly Hallows", "The Way of Kings", "The Book Thief", "The Eye of the World"),
  author_id = rep(c(1, 2, 3, 4), c(7, 1, 1, 1)),
  rating = c(4.47, 4.43, 4.57, 4.56, 4.5, 4.57, 4.62, 4.64, 4.37, 4.18)
)

authors <- data.frame(
  id = 1:10,
  name = c("J.K. Rowling", "Brandon Sanderson", "Markus Zusak", "Robert Jordan", "Agatha Christie", "Alex Kava", "Nassim Nicholas Taleb", "Neil Gaiman", "Stieg Larsson", "Antoine de Saint-Exupry"),
  avg_rating = c(4.46, 4.39, 4.34, 4.18, 4.0, 4.02, 3.99, 4.13, 4.16, 4.3)
)
```

#### Examples {#r-basic-merge-examples}

Consider the data.frame's `books` and `authors`:

```{r}
books
```

```{r}
authors
```

##### How do I merge the author information from `authors` based on `author_id` in `books` and `id` in `authors`, keeping only information from `authors` and `books` where there is a match?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
# In SQL this is referred to as an INNER JOIN.
merge(books, authors, by.x="author_id", by.y="id", all=F)
```
</details>

##### How do I merge the author information from `authors` based on `author_id` in `books` and `id` in `authors`, keeping all information from `authors` regardless of whether or not there is match?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
merge(books, authors, by.x="author_id", by.y="id", all.y=T)

# or

merge(authors, books, by.x="id", by.y="author_id", all.x=T)
```
</details>

## Data.frames {#r-data-frames}

Data.frames are one of the primary data structure used very frequently when working in R. Data.frames are tables of same-sized, named columns, where each column has a single type.

You can create a data.frame easily:

```{r}
df <- data.frame(cat_1=c(1,2,3), cat_2=c(9,8,7), ok=c(T, T, F), other=c("first", "second", "third"))
head(df)
```

Regular indexing rules apply as well. This is how you index rows. Pay close attention to the trailing comma:

```{r}
# Numeric indexing on rows:
df[1:2,]
df[c(1,3),]
```

```{r}
# Logical indexing on rows:
df[c(T,F,T),]
```

```{r}
# Named indexing on rows only works 
# if there are named rows:
row.names(df) <- c("row1", "row2", "row3")
df[c("row1", "row3"),]
```

By default, if you don't include the comma in the square brackets, you are indexing the column:

```{r}
df[c("cat_1", "ok")]
```

To index columns, place expressions after the first comma:

```{r}
# Numeric indexing on columns:
df[, 1]
df[, c(1,3)]
```

```{r}
# Logical indexing on columns:
df[, c(T, F, F, F)]
```

```{r}
# Named indexing on columns.
# This is the more typical method of 
# column indexing:
df$cat_1
```

```{r}
# Another way to do named indexing on columns:
df[,c("cat_1", "ok")]
```

Of course, you can index on columns and rows:

```{r}
# Numeric indexing on columns and rows:
df[1:2, 1]
df[1:2, c(1,3)]
```

```{r}
# Logical indexing on columns and rows:
df[c(T,F,T), c(T, F, F, F)]
```

```{r}
# Named indexing on columns and rows.
# This is the more typical method of 
# column indexing:
df$cat_1[c(T,F,T)]
```

```{r}
# Another way to do named indexing on columns and rows:
row.names(df) <- c("row1", "row2", "row3")
df[c("row1", "row3"),c("cat_1", "ok")]
```

#### Examples {#r-data-frame-examples}

```{r, include=F}
df <- data.frame(cat_1=c(1,2,3), cat_2=c(9,8,7), ok=c(T, T, F), other=c("first", "second", "third"))
```

##### How can I get the first 2 rows of a data.frame named `df`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
df <- data.frame(cat_1=c(1,2,3), cat_2=c(9,8,7), ok=c(T, T, F), other=c("first", "second", "third"))
df[1:2,]
```
</details>

##### How can I get the first 2 columns of a data.frame named `df`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
df[,1:2]
```
</details>

##### How can I get the rows where values in the column named `cat_1` are greater than 2?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
df[df$cat_1 > 2,]
```
```{r, eval=T}
df[df[, c("cat_1")] > 2,]
```

</details>

##### How can I get the rows where values in the column named `cat_1` are greater than 2 and the values in the column named `cat_2` are less than 9?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
df[df$cat_1 > 2 & df$cat_2 < 9,]
```
</details>

##### How can I get the rows where values in the column named `cat_1` are greater than 2 or the values in the column named `cat_2` are less than 9?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
df[df$cat_1 > 2 | df$cat_2 < 9,]
```
</details>

##### How do I sample _n_ rows randomly from a data.frame called `df`?
<details>
    <summary>Click here for solution</summary>
    
```{r, eval=F}
df[sample(nrow(df), n),]
```

Alternatively you could use the `sample_n` function from the package `dplyr`:
```{r, eval=F}
sample_n(df, n)
```
</details>

##### How can I get only columns whose names start with "cat_"?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
df <- data.frame(cat_1=c(1,2,3), cat_2=c(9,8,7), ok=c(T, T, F), other=c("first", "second", "third"))
df[, grep("^cat_", names(df))]
```
</details>

## Reading & Writing data {#r-reading-and-writing-data}

### Examples {#r-reading-and-writing-data-examples}

#### How do I read a csv file called `grades.csv` into a data.frame? {#r-read}

<details>
    <summary>Click here for solution</summary>
    
Note that the "." means the current working directory. So, if we were in "/home/john/projects", "./grades.csv" would be the same as "/home/john/projects/grades.csv". This is called a _relative_ path. Read [this](#dots) for a better understanding. 

```{r, eval=T}
dat <- read.csv("./grades.csv")
head(dat)
```
</details>

#### How do I read a csv file called `grades.csv` into a data.frame using the function `fread`? {#r-fread}

<details>
    <summary>Click here for solution</summary>
    
**Note**: The function `fread` is part of the `data.table` package and which reads in dataset faster than `read.csv`. It is therefore recommended for reading in large datasets in R.

    ```{r, eval=T}
library(data.table)
dat <- data.frame(fread("./grades.csv"))
head(dat)
```

</details>

#### How do I read a csv file called `grades2.csv` where instead of being comma-separated, it is semi-colon-separated, into a data.frame?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
dat <- read.csv("./grades_semi.csv", sep=";")
head(dat)
```
</details>

#### How do I prevent R from reading in strings as factors when using a function like `read.csv`?

<details>
    <summary>Click here for solution</summary>
In R 4.0+, strings are not read in as factors, so you do not need to do anything special. For R < 4.0, use `stringsAsFactors`.

```{r, eval=T}
dat <- read.csv("./grades.csv", stringsAsFactors=F)
head(dat)
```
</details>

#### How do I specify the type of 1 or more columns when reading in a csv file?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
dat <- read.csv("./grades.csv", colClasses=c("grade"="character", "year"="factor"))
str(dat)
```
</details>

#### Given a list of csv files with the same columns, how can I read them in and combine them into a single dataframe?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
# We want to read in grades.csv, grades2.csv, and grades3.csv 
# into a single dataframe.

list_of_files <- c("grades.csv", "grades2.csv", "grades3.csv")

results <- data.frame()
for (file in list_of_files) {
  dat <- read.csv(file)
  results <- rbind(results, dat)
}
dim(results)
```
</details>

#### How do I create a data.frame with comma-separated data that I've copied onto my clipboard?

<details>
    <summary>Click here for solution</summary>
```{r, eval=F}
# For mac
dat <- read.delim(pipe("pbpaste"),header=F,sep=",")

# For windows
dat <- read.table("clipboard",header=F,sep=",")
```
</details>

## Control flow {#r-control-flow}

### If/else statements {#r-if-else}

If, else if, and else statements are methods for controlling whether or not an operation is performed based on the result of some expression. 

#### How do I print "Success!" if my expression evaluates to `TRUE`, and "Failure!" otherwise?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
# Randomly assign either TRUE or FALSE to t_or_f.
t_or_f <- sample(c(TRUE,FALSE),1)

if (t_or_f == TRUE) {
  # If t_or_f is TRUE, print success
  print("Success!")
} else {
  # Otherwise, print failure
  print("Failure!")
}

# You don't need to put the full expression.
# This is the same thing because t_or_f
# is already TRUE or FALSE. 
# TRUE == TRUE evaluates to TRUE and
# FALSE == TRUE evaluates to FALSE.
if (t_or_f) {
  # If t_or_f is TRUE, print success
  print("Success!")
} else {
  # Otherwise, print failure
  print("Failure!")
}
```
</details>

#### How do I print "Success!" if my expression evaluates to `TRUE`, "Failure!" if my expression evaluates to `FALSE`, and "Huh?" otherwise?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
# Randomly assign either TRUE or FALSE to t_or_f.
t_or_f <- sample(c(TRUE,FALSE, "Something else"),1)

if (t_or_f == TRUE) {
  # If t_or_f is TRUE, print success
  print("Success!")
} else if (t_or_f == FALSE) {
  # If t_or_f is FALSE, print failure
  print("Failure!")
} else {
  # Otherwise print huh
  print("Huh?")
}

# In this case you need the full expression because
# "Something else" does not evaluate to TRUE or FALSE
# which will cause an error as the if and else if 
# statements expect a result of TRUE or FALSE.
if (t_or_f == TRUE) {
  # If t_or_f is TRUE, print success
  print("Success!")
} else if (t_or_f == FALSE) {
  # If t_or_f is FALSE, print failure
  print("Failure!")
} else {
  # Otherwise print huh
  print("Huh?")
}
```
</details>

### For loops {#r-for-loops}

For loops allow us to execute similar code over and over again until we've looped through all of the elements. They are useful for performing the same operation to an entire vector of input, for example. 

Using the suite of apply functions is more common in R. It is often said that the apply suite of function are much faster than for loops in R. While this used to be the case, this is no longer true. 

#### Examples {#r-for-loops-examples}

##### How do I loop through every value in a vector and print the value?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
for (i in 1:10) {
  # In the first iteration of the loop,
  # i will be 1. The next, i will be 2.
  # Etc.
  print(i)
}
```
</details>

##### How do I break out of a loop before it finishes?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
for (i in 1:10) {
  if (i==7) {
    # When i==7, we will exit the loop.
    break
  }
  print(i)
}
```
</details>

##### How do I loop through a vector of names?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
friends <- c("Phoebe", "Ross", "Rachel", "Chandler", "Joey", "Monica")
my_string <- "So no one told you life was gonna be this way, "
for (friend in friends) {
  print(paste0(my_string, friend, "!"))
}
```
</details>

##### How do I skip a loop if some expression evaluates to `TRUE`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
friends <- c("Phoebe", "Ross", "Mike", "Rachel", "Chandler", "Joey", "Monica")
my_string <- "So no one told you life was gonna be this way, "
for (friend in friends) {
  if (friend == "Mike") {
    # next, skips over the rest of the code for this loop
    # and continues to the next element
    next
  }
  print(paste0(my_string, friend, "!"))
}
```
</details>

##### Are there examples in which for loops are not appropriate to use? {#r-for-loops-versus-vectorized-functions}

<details>
    <summary>Click here for solution</summary>

This is usually how we write loops in other languages, e.g., C, C++, Java, Python, etc., if we want to add the first 10 billion integers.
```{r, eval=T}
mytotal <- 0
for (i in 1:10000000000) {
  mytotal <- mytotal + i
}
mytotal
```

but this takes a long time to evaluate.  It is easier to write, and much faster to evaluate, if we use the `sum` function, which is vectorized, i.e., which works on an entire vector of data all at once.

Here, for instance, we add the first 10 billion integers, and the computation occurs almost immediately.
```{r, eval=T}
sum(1:10000000000)
```

**[Click here for video](https://cdnapisec.kaltura.com/p/983291/sp/98329100/embedIframeJs/uiconf_id/29134031/partner_id/983291?iframeembed=true&playerId=kaltura_player&entry_id=1_1zf8kq5h&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_agm08ttm)**

</details>

##### Can you show an example of how to do the same thing, with a for loop and without a for loop? {#r-example-for-loops-compared-to-vectorized-functions}

<details>
    <summary>Click here for solution</summary>

Yes, here is an example about how to compute the average cost of a line of the grocery store data.

```{r, eval=F}
myDF <- read.csv("/class/datamine/data/8451/The_Complete_Journey_2_Master/5000_transactions.csv")
head(myDF)
```

```{r, echo=F}
myDF <- transactions_5000
head(myDF)
```

This is how we find the average cost per line in other languages, for instance, C/C++, Python, Java, etc.
```{r, eval=T}
amountspent <- 0       # we initialize a variable to keep track of the entire price of the purchases
numberofitems <- 0     # and we initialize a variable to keep track of the number of purchases
for (myprice in myDF$SPEND) {
  amountspent <- amountspent + myprice     # we add the price of the current purchase
  numberofitems <- numberofitems + 1       # and we increment (by 1) the number o purchases processed so far
}
amountspent     # this is the total amount spent on all purchases
numberofitems   # this is the total number of purchases
amountspent/numberofitems       # so this is the average
amountspent/length(myDF$SPEND)  # this is an equivalent way to compute the average
```

For comparison, this is the much easier way that we can use a vectorized function in R, to accomplish the same purpose.  The vector is the column `myDF$SPEND`.  We can just focus our attention on that column from the data frame, and take a mean.
```{r, eval=T}
mean(myDF$SPEND)
```

**[Click here for video](https://cdnapisec.kaltura.com/p/983291/sp/98329100/embedIframeJs/uiconf_id/29134031/partner_id/983291?iframeembed=true&playerId=kaltura_player&entry_id=1_pz7cg2sc&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_y3e1j45c)**

</details>

##### Can you show an example of how to make a new column in a data frame, which classifies things, based on another column? {#r-example-safe-versus-contaminated}

<details>
    <summary>Click here for solution</summary>

Yes, we can make a new column in the grocery store data set.

```{r, eval=F}
myDF <- read.csv("/class/datamine/data/8451/The_Complete_Journey_2_Master/5000_transactions.csv")
head(myDF)
```

```{r, echo=F}
myDF <- transactions_5000
head(myDF)
```

Let's first make a new vector (the same length as a column of the data frame) in which all of the entries are `safe`.

```{r, eval=T}
mystatus <- rep("safe", times=nrow(myDF))
```

and then we can change the entries for the elements of `mystatus` that occurred on `05-JUL-16` or on `06-JUL-16` to be `contaminated`.
```{r, eval=T}
mystatus[(myDF$PURCHASE_ == "05-JUL-16")|(myDF$PURCHASE_ == "06-JUL-16")] <- "contaminated"
```

and finally change this into a factor, and add it as a new column in the data frame.
```{r, eval=T}
myDF$safetystatus <- factor(mystatus)
```

Now the head of the data frame looks like this:
```{r, eval=T}
head(myDF)
```

and the number of `contaminated` rows versus `safe` rows is this:
```{r, eval=T}
table(myDF$safetystatus)
```

**[Click here for video](https://cdnapisec.kaltura.com/p/983291/sp/98329100/embedIframeJs/uiconf_id/29134031/partner_id/983291?iframeembed=true&playerId=kaltura_player&entry_id=1_fru4k006&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_cxr17wtf)**

</details>



## Apply functions {#r-apply-functions}

```{r, include=F}
my_list <- list(
  pages = c(1,2,3,4,5),
  words = c(10,20,30,40,50),
  letters = c(100,200,300,400,500)
)
```

### `apply` {#r-apply}

### `lapply` {#r-lapply}

The `lapply` is a function that applies a function `FUN` to each element in a vector or list, and returns a list.

#### Examples {#r-lapply-examples}

##### How do I get the mean value of each vector in our list, `my_list`, in another list? 

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
lapply(my_list, mean)
```
</details>

##### How can I find the average of several variables in the flight data, using only 1 line of R, with the `lapply` function? {#r-lapply-flight-example}

**[Click here for video](https://cdnapisec.kaltura.com/p/983291/sp/98329100/embedIframeJs/uiconf_id/29134031/partner_id/983291?iframeembed=true&playerId=kaltura_player&entry_id=1_djp6bltk&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_xgmfh99r)**

These are the flights from 2003:

```{r, eval=F}
myDF <- read.csv("/class/datamine/data/flights/subset/2003.csv")
```

We can break the flights into categories, depending on the `Distance` of the flight:

less than 100 miles; from 100 to 200 miles; from 200 to 500 miles; from 500 to 1000 miles; from 1000 to 2000 miles; more than 2000 miles

```{r, eval=F}
my_distance_categories <- cut(myDF$Distance, breaks = c(0,100,200,500,1000,2000,Inf), include.lowest=T)
```

The numbers of flights in each category are:
```{r, eval=F}
table(my_distance_categories)
```

Here are the average values of 4 variables, in each of these 6 categories:
```{r, eval=F}
tapply( myDF$DepDelay, my_distance_categories, mean, na.rm=T) # the DepDelay in each category
tapply( myDF$ArrDelay, my_distance_categories, mean, na.rm=T) # the ArrDelay in each category
tapply( myDF$TaxiOut, my_distance_categories, mean, na.rm=T) # the time to TaxiOut in each category
tapply( myDF$TaxiIn, my_distance_categories, mean, na.rm=T) # the time to TaxiIn in each category
```

OR, MUCH EASIER:  We can do all of this with just 1 line of R.  To make it easier to read, we can make a temporary data frame `flights_by_distance` with these 4 variables.  Then we split the data into 6 data frames, according to the `Distance` of the flights, and we get the average `DepDelay`, `ArrDelay`, `TaxiOut`, and `TaxiIn`, in each of these 6 categories, with only 1 line of R.  Notice that this agrees *exactly* with the results of the 4 separate `tapply` functions, but it only takes us 1 call to the `lapply` function!!
```{r, eval=F}
flights_by_distance <- split( data.frame(myDF$DepDelay, myDF$ArrDelay, myDF$TaxiOut, myDF$TaxiIn), my_distance_categories )
lapply( flights_by_distance, colMeans, na.rm=T )
```

Some closing remarks about this example:

We use lapply on a `list`.  It only takes two arguments, namely, a `list` and a `function` to run on each piece of our `list`.  In this case, we are taking an average (`colMeans`) of each column in each piece of our `list`.

The `flights_by_distance` is a `list` of 6 data frames  You might want to check these out.
```{r, eval=F}
class( flights_by_distance )
length( flights_by_distance )
class(flights_by_distance[[1]])
class(flights_by_distance[[2]])
class(flights_by_distance[[3]])
class(flights_by_distance[[4]])
class(flights_by_distance[[5]])
class(flights_by_distance[[6]])
head(flights_by_distance[[1]])
head(flights_by_distance[[2]])
head(flights_by_distance[[3]])
head(flights_by_distance[[4]])
head(flights_by_distance[[5]])
head(flights_by_distance[[6]])
```

You can take the `colMeans` within each of these data frames, like this:
```{r, eval=F}
colMeans(flights_by_distance[[1]], na.rm=T)
colMeans(flights_by_distance[[2]], na.rm=T)
colMeans(flights_by_distance[[3]], na.rm=T)
colMeans(flights_by_distance[[4]], na.rm=T)
colMeans(flights_by_distance[[5]], na.rm=T)
colMeans(flights_by_distance[[6]], na.rm=T)
```
but this is all accomplished by the 1-line `lapply` that we did earlier, in a much easier way.

##### How can I find the average of several variables in the fars data, using only 1 line of R, with the `lapply` function? {#r-lapply-fars-example}

**[Click here for video](https://cdnapisec.kaltura.com/p/983291/sp/98329100/embedIframeJs/uiconf_id/29134031/partner_id/983291?iframeembed=true&playerId=kaltura_player&entry_id=1_djp6bltk&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_xgmfh99r)**

This is the fars data set, studied in STAT 19000 Project 6 (only the years 1975 to 1981)

```{r, eval=F}
dat <- read.csv("/class/datamine/data/fars/7581.csv")
```

We will learn a more efficient way to add the state names but for now, we do this in the same way as Project 6.

```{r, eval=F}
state_names <- read.csv("/class/datamine/data/fars/states.csv")
v <- state_names$state
names(v) <- state_names$code
dat$mystates <- v[as.character(dat$STATE)]
```

In Project 6, Question 2, we found the average number of `DRUNK_DR`, according to the state:
```{r, eval=F}
tapply( dat$DRUNK_DR, dat$mystates, mean)
```
We might also want to find the average number fatalities (`FATALS`) per accident, according to the state:
```{r, eval=F}
tapply( dat$FATALS, dat$mystates, mean)
```
and the average number of people (`PERSONS`) involved per accident, according to the state:
```{r, eval=F}
tapply( dat$PERSONS, dat$mystates, mean)
```

OR, MUCH EASIER:  We can do all 3 of these calculations with just 1 line of R.  To make it easier to read, we can make a temporary data frame `accidents_by_state` with these 3 variables. Then we split the data into 51 data frames, according to the state where the accident occurred, and we get the average `DRUNK_DR`, `FATALS`, and `PERSONS` in each of these 51 categories, with only 1 line of R. Notice that this agrees **exactly** with the results of the 3 separate `tapply` functions, but it only takes us 1 call to the `lapply` function!!

```{r, eval=F}
accidents_by_state <- split( data.frame(dat$DRUNK_DR, dat$FATALS, dat$PERSONS), dat$mystates )
lapply( accidents_by_state, colMeans )
```

Again, some closing remarks:  We use `lapply` on a list. It only takes two arguments, namely, a `list` and a `function` to run on each piece of our list. In this case, we are taking an average (`colMeans`) of each column in each piece of our list.

The `accidents_by_state` is a list of 51 data frames.  You might want to check these out.
```{r, eval=F}
class( accidents_by_state )
length( accidents_by_state )
class(accidents_by_state[[1]])
class(accidents_by_state[[2]])
# etc., etc.
class(accidents_by_state[[50]])
class(accidents_by_state[[51]])
```

```{r, eval=F}
head(accidents_by_state[[1]])
head(accidents_by_state[[2]])
# etc., etc.
head(accidents_by_state[[50]])
head(accidents_by_state[[51]])
```

You can also extract the elements of the list according to their names, e.g.,
```{r, eval=F}
head(accidents_by_state$Indiana)
colMeans(accidents_by_state$Indiana)

head(accidents_by_state$Illinois)
colMeans(accidents_by_state$Illinois)

head(accidents_by_state$Ohio)
colMeans(accidents_by_state$Ohio)

head(accidents_by_state$Michigan)
colMeans(accidents_by_state$Michigan)
```

but this is all accomplished by the 1-line `lapply` that we did earlier, in a much easier way.


### `sapply` {#r-sapply}

`sapply` is very similar to `lapply`, however, where `lapply` always returns a list, `sapply` will simplify the output of applying the function `FUN` to each element. 

If you recall, when accessing an element in a list using single brackets `my_list[1]`, the result will always return a list. If you access an element with double brackets `my_list[[1]]`, `R` will attempt to simplify the result. This is analogous to `lapply` and `sapply`.

#### Examples {#r-sapply-examples}

##### How do I get the mean value of each vector in our list, `my_list`, but rather than the result being a list, put the results in the simplest form?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
sapply(my_list, mean)
```
</details>

##### Use the provided function to create a new column in the data.frame `example_df` named `transformed`. `transformed` should contain `TRUE` if the value in `pre_transformed` is "t", `FALSE` if it is "f", and NA otherwise.

```{r, eval=T}
string_to_bool <- function(value) {
  if (value == "t") {
    return(TRUE)
  } else if (value == "f") {
    return(FALSE)
  } else {
    return(NA)
  }
}

example_df <- data.frame(pre_transformed=c("f", "f", "t", "f", "something", "t", "else", ""), other=c(1,2,3,4,5,6,7,8))
example_df
```

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
example_df$transformed <- sapply(example_df$pre_transformed, string_to_bool)
example_df
```
</details>

### `tapply` {#r-tapply}

`tapply` is described in the documentation as a way to "apply a function to each cell of a ragged array, that is to each (non-empty) group of values given by a unique combination of the levels of certain factors." This is not a very useful description. 

An alternative way to think about `tapply`, is as a function that allows you to calculate or apply `function` to `data1` when `data1` is grouped by `data2`.

`tapply(data1, data2, function)`

A concrete example would be getting the _mean_ (`function`) _grade_ (`data1`) when _grade_ (`data1`) is grouped by _year_ (`data2`):

```{r, include=F}
grades <- grades
```

```{r, eval=T}
grades
```

```{r}
tapply(grades$grade, grades$year, mean)
```

If your `function` (in this case _mean_), requires extra arguments, you can pass those by name to `tapply`. This is what the `...` argument in `tapply` is for. For example, if we want our _mean_ function to remove na's prior to calculating a mean we could do the following:

```{r}
tapply(grades$grade, grades$year, mean, na.rm=T)
```

#### Examples #{r-tapply-examples}

##### Amazon fine food tapply example {#r-Amazon-tapply-example}

Here is an example using the Amazon fine food reviews
```{r, eval=F}
myDF <- read.csv("/class/datamine/data/amazon/amazon_fine_food_reviews.csv")
```

This is the data source:
https://www.kaggle.com/snap/amazon-fine-food-reviews/

The people who wrote the most reviews are
```{r, eval=F}
tail(sort(table(myDF$UserId)))
```

In particular, user A3OXHLG6DIBRW8 wrote the most reviews.

The total number of people who read reviews that were written by A3OXHLG6DIBRW8 is:
```{r, eval=F}
sum(myDF$HelpfulnessDenominator[myDF$UserId == "A3OXHLG6DIBRW8"])
```

The number of people who found those reviews (written by A3OXHLG6DIBRW8) to be helpful is:
```{r, eval=F}
sum(myDF$HelpfulnessNumerator[myDF$UserId == "A3OXHLG6DIBRW8"])
```

So, altogether, when people read the reviews written by user A3OXHLG6DIBRW8,
these reviews were rated as helpful 0.9795918 of the time
```{r, eval=F}
sum(myDF$HelpfulnessNumerator[myDF$UserId == "A3OXHLG6DIBRW8"])/sum(myDF$HelpfulnessDenominator[myDF$UserId == "A3OXHLG6DIBRW8"])
```

Now we can do this again, for all users.

The total number of people who read reviews altogether, grouped by the user who wrote the review, is
```{r, eval=F}
head( tapply(myDF$HelpfulnessDenominator, myDF$UserId, sum) )
```

The total number of people who rated reviews as helpful, grouped by the user who wrote the review, is
```{r, eval=F}
head( tapply(myDF$HelpfulnessNumerator, myDF$UserId, sum) )
```

The percentages of people who found reviews to be helpful, grouped according to who wrote the review, are
```{r, eval=F}
head( tapply(myDF$HelpfulnessNumerator, myDF$UserId, sum)/tapply(myDF$HelpfulnessDenominator, myDF$UserId, sum) )
```

We can double-check our result for user "A3OXHLG6DIBRW8" as follows
```{r, eval=F}
( tapply(myDF$HelpfulnessNumerator, myDF$UserId, sum)/tapply(myDF$HelpfulnessDenominator, myDF$UserId, sum) )["A3OXHLG6DIBRW8"]
```

**[Click here for video](https://cdnapisec.kaltura.com/p/983291/sp/98329100/embedIframeJs/uiconf_id/29134031/partner_id/983291?iframeembed=true&playerId=kaltura_player&entry_id=1_24jmfygn&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_dti6orbo)**

## Writing functions {#r-writing-functions}

In a nutshell, a function is a set of instructions or actions packaged together in a single definition or unit. Typically, function accept 0 or more _arguments_ as input, and returns 0 or more results as output. The following is an example of a function in `R`:

```{r}
# word_count is a function that accepts a sentence as an argument,
# strips punctuation and extra space, and returns the number of 
# words in the sentence.
word_count <- function(sentence) {
  # strip punctuation and save into an auxiliary variable
  aux <- gsub('[[:punct:]]+','', sentence)
  
  # split the sentence by space and remove extra spaces
  result <- sum(unlist(strsplit(aux, " ")) != "")
  return(result)
}
test_sentence <- "this is a  sentence, with 7 words."
word_count(test_sentence)
```

The function is named `word_count`. The function has a single _parameter_ named `sentence`. The function returns a single value, `result`, which is the number of words in the provided sentence. `test_sentence` is the _argument_ to `word_count`. An _argument_ is the actual value passed to the function. We _pass_ values to functions -- this just means we use the values as _arguments_ to the function. The _parameter_, `sentence`, is the name shown in the function definition.

Functions can have helper functions. A helper function is a function defined and used within another function in order to reduce complexity or make the task at hand more clear. For example, we could have written the previous function differently:

```{r}
# word_count is a function that accepts a sentence as an argument,
# strips punctuation and extra space, and returns the number of 
# words in the sentence.
word_count <- function(sentence) {
  
  # a helper function that takes care of removing
  # punctuation and extra spaces.
  split_and_clean <- function(sentence) {
    # strip punctuation and save into an auxiliary variable
    aux <- gsub('[[:punct:]]+','', sentence)
    
    # remove extra spaces
    aux <- unlist(strsplit(aux, " "))
    
    return(aux[aux!=""])
  }
  
  # return the length of the sentence
  result <- length(split_and_clean(sentence))
  return(result)
}
test_sentence <- "this is a  sentence, with 7 words."
word_count(test_sentence)
```

Here, our helper function is named `split_and_clean`. If you try to call `split_and_clean` outside of `word_count`, you will get an error. `split_and_clean` is defined within the scope of `word_count` and is not available outside that scope. In this example, `word_count` is the _caller_, the function that _calls_ the other function, `split_and_clean`. The other function, `split_and_clean`, can be referred to as the `callee`.

In `R` functions can be passed to other functions as arguments. In general, functions that accept another function as an argument or return functions, are called higher order functions. Some examples of higher order functions in R are `sapply`, `lapply`, `tapply`, `Map`, and `Reduce`. The function passed as an argument, is often referred to as a _callback function_, as the _caller_ is expected to call back (execute) the argument at a later point in time.

### `...` {#r-ellipsis}

The ellipsis `...` in `R` can be used to pass an unknown number of arguments to a function. For example, if you look at the documentation for `sapply` (`?sapply`), you will see the following in the usage section:

```{r, eval=F}
sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)
```

In the arguments section, it says the ellipsis are "optional arguments to FUN". `sapply` uses the ellipsis as a vehicle to pass an unknown number of arguments to the callback function. In practice, this could look something like:

```{r}
dims <- function(..., sort=F) {
  args <- list(...)
  arg_names <- names(args)
  results <- lapply(args, dim)
  
  if (is.null(arg_names) | sort==FALSE) {
    # arguments not passed with a name
    return(results)
  }
  
  return(results[order(names(results))])
}

dims(grades)
dims(grades, my_mat)
dims(xyz=grades, abc=my_mat)
dims(xyz=grades, abc=my_mat, sort=T)
```

Here, `dims` accepts any number of data.frame-like objects, `...`, and a logical value indicating whether or not to sort the list by names. As you can see, if arguments are passed to `dims` with names, those names can be accessed within `dims` via `names(list(...))`. 

### Examples {#r-writing-functions-examples}

#### Create a function named `should_be_transformed` that, given a value, returns `TRUE` if the value is "t", and `FALSE` if the value is "f", and NA otherwise. 

```{r, eval=T}
example_df <- data.frame(column_to_test=c("f", "f", "t", "f", "something", "t", "else", ""), other=c(1,2,3,4,5,6,7,8))
example_df
```

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
should_be_transformed <- function(value) {
  if (value == "t") {
    return(TRUE)
  } else if (value == "f") {
    return(FALSE)
  } else {
    return(NA)
  }
}

should_be_transformed(example_df$column_to_test[1])
should_be_transformed(example_df$column_to_test[3])
should_be_transformed(example_df$column_to_test[5])
```
</details>

## Plotting {#r-plotting}

### `barplot` {#r-barplot}

`barplot` is a function that creates a barplot. Barplots are used to display categorical data. The following is an example of plotting some data from the precip dataset.

```{r, eval=T}
barplot(precip[1:10])
```

As you can see, the x-axis labels are bad. What if we turn the labels to be vertical?

```{r, eval=T}
barplot(precip[1:10], las=2)
```

Much better, however, some of the longer names go off of the plot. Let's fix this:

```{r, eval=T}
par(oma=c(3,0,0,0)) # oma stands for outer margins. We increase the bottom margin to 3.
barplot(precip[1:10], las=2)
```

This is even better, however, it would be nice to have a title and axis label(s).

```{r, eval=T}
par(oma=c(3,0,0,0)) # oma stands for outer margins. We increase the bottom margin to 3.
barplot(precip[1:10], las=2, main="Average Precipitation", ylab="Inches of rain")
```

We are getting there. Let's add some color.

```{r, eval=T}
par(oma=c(3,0,0,0)) # oma stands for outer margins. We increase the bottom margin to 3.
barplot(precip[1:10], las=2, main="Average Precipitation", ylab="Inches of rain", col="blue")
```

What if we want different colors for the different cities?

```{r, eval=T}
library(RColorBrewer)
par(oma=c(3,0,0,0)) # oma stands for outer margins. We increase the bottom margin to 3.
colors <- brewer.pal(10, "Set3") 
barplot(precip[1:10], las=2, main="Average Precipitation", ylab="Inches of rain", col=colors)
```

What if instead of x-axis labels, we want to use a legend?

```{r, eval=T}
library(RColorBrewer)
par(oma=c(0,0,0,0)) # oma stands for outer margins. We increase the bottom margin to 3.
colors <- brewer.pal(10, "Set3") 
barplot(precip[1:10], las=2, main="Average Precipitation", ylab="Inches of rain", col=colors, legend=T, names.arg=F)
```

Pretty good, but now we don't need so much space at the bottom, and we need to make space for that legend. We use `xlim` to increase the x-axis, and `args.legend` to move the position of the legend along the x and y axes.

```{r, eval=T}
library(RColorBrewer)
colors <- brewer.pal(10, "Set3") 
barplot(precip[1:10], las=2, main="Average Precipitation", ylab="Inches of rain", col=colors, legend=T, names.arg=F, xlim=c(0, 15), args.legend=list(x=16.5, y=46))
```

It's looking good, let's remove the box around the legend:

```{r, eval=T}
library(RColorBrewer)
colors <- brewer.pal(10, "Set3") 
barplot(precip[1:10], las=2, main="Average Precipitation", ylab="Inches of rain", col=colors, legend=T, names.arg=F, xlim=c(0, 15), args.legend=list(x=16.5, y=46, bty="n"))
```

### `boxplot` {#r-boxplot}

`boxplot` is a function that creates a box and whisker plot, given some grouped data. The following is an example using the trees dataset.

First, we break our data into groups based on height. 

```{r}
dat <- trees
dat$size <- cut(trees$Height, breaks=c(0,76,100))
levels(dat$size) <- c("short", "tall")
```

Next, we start with a box plot:

```{r}
boxplot(dat$Girth ~ dat$size)
```

Let's spruce things up with proper labels:

```{r}
boxplot(dat$Girth ~ dat$size, main="Tree girth", ylab="Girth in Inches", names=c("Short", "Tall"), xlab="")
```

Let's add color:

```{r}
boxplot(dat$Girth ~ dat$size, main="Tree girth", ylab="Girth in Inches", names=c("Short", "Tall"), xlab="", border="darkgreen", col="lightgreen")
```

### `pie` {#r-pie}

`pie` is a function that creates a piechart.`pie` charts are used to display categorical data. The following is an example using the `USPersonalExpenditure` dataset.

First, let's get the mean expenditure:
```{r}
# Quick look at data:
USPersonalExpenditure
# Mean expenditure
expenditure <- rowMeans(USPersonalExpenditure)
```

Now, we can create our pie chart.

```{r}
pie(expenditure)
```

Let's use some different colors!

```{r}
pie(expenditure, col = c("#8E6F3E", "#1c5253","#23395b","#6F727B", "#F97B64"))
```

Let's add the percentages next to the names. To do so, we must first get those values:

```{r}
# calculating percentages 
expenditure_percentage <- 100*expenditure/sum(expenditure)
# rounding percentages to 2 decimal places
expenditure_percentage <- round(expenditure_percentage, 2)
# combining names with percentages
expenditure_names <- paste0(names(expenditure), " (", expenditure_percentage, "%)")
# creating new labels
pie(expenditure, labels = expenditure_names, col = c("#8E6F3E", "#1c5253","#23395b","#6F727B", "#F97B64"))
```

Let's add a title:

```{r}
pie(expenditure, labels = expenditure_names, col = c("#8E6F3E", "#1c5253","#23395b","#6F727B", "#F97B64"), main = "Mean US expenditure from 1940 to 1960")
```

### `dotchart` {#r-dotchart}

`dotchart` draws a [Cleveland dot plot](https://en.wikipedia.org/wiki/Dot_plot_(statistics)). 

**Fun Fact:** [Dr. Cleveland](https://www.stat.purdue.edu/people/faculty/wsc) is a Distinguished Professor in the [Statistics department](https://www.stat.purdue.edu/people/index.html) at Purdue University!

The following is an example using the built-in `HairEyeColor` dataset. 

First, let's consider only individuals with black hair.

```{r}
# Selecting only individuals with black hair
black_hair = HairEyeColor[1,,]

# Summing both Male and Female.
black_hair = rowSums(black_hair)
```

Now we can create our dotchart.

```{r}
dotchart(black_hair)
```

Let's add a title, and labels to the x-axis and the y-axis.

```{r}
dotchart(black_hair, main='Eye color for individuals with black hair', xlab='Count', ylab='Eye color')
```

That's better. Let's arrange the data in an ascending manner.

```{r}
# re-ordering the data
black_hair <- sort(black_hair)
dotchart(black_hair, main='Eye color for individuals with black hair', xlab='Count', ylab='Eye color') 
```

How about some color?

```{r}
dotchart(black_hair, main='Eye color for individuals with black hair', xlab='Count', ylab='Eye color', bg='orange')
```

### `plot` {#r-plot}

`plot` is a generic plotting function. It creates scatter plots as well as line plots. The argument `type` allows you to define the type of plot that should be drawn. Most common `type`s are "p" for points (default), "l" for lines, and "b" for both.

#### Scatter plots

Below is an example using the built-in `Orange` dataset. 

```{r}
plot(Orange$age, Orange$circumference)
```

The labels for x-axis and y-axis can be improved!

```{r}
plot(Orange$age, Orange$circumference, xlab='Tree age', ylab='Tree circumference')
```

We can also add a title.

```{r}
plot(Orange$age, Orange$circumference, xlab='Tree age', ylab='Tree circumference', main='Growth of orange trees')
```

The argument [`pch`](http://www.sthda.com/english/wiki/r-plot-pch-symbols-the-different-point-shapes-available-in-r) specifies what symbol to use when plotting. `pch` set at "21" enables us to have colored circles. We can specify both the border and fill colors. Let's give it a try.

```{r}
plot(Orange$age, Orange$circumference, xlab='Tree age', ylab='Tree circumference', main='Growth of orange trees', pch=21, bg='lightblue', col='tomato')
```

How about coloring the points based on the tree?

```{r}
plot(Orange$age, Orange$circumference, xlab='Tree age', ylab='Tree circumference', main='Growth of orange trees', pch=21, bg=Orange$Tree)
```

#### Line plots

Below is an example using the built-in `Orange` dataset. 

```{r}
plot(Orange$age, Orange$circumference, type='l')
```

Let's fix the title and axes labels.

```{r}
plot(Orange$age, Orange$circumference, type='l', xlab='Tree age', ylab='Tree circumference', main='Growth of orange trees')
```

`lty` is an argument that allows us to change the linetype. This is the equivalent version of `pch` for lines. There 7 options: "blank", "solid", "dashed", "dotted", "dotdash", "longdash", and "twodash". 

```{r}
plot(Orange$age, Orange$circumference, type='l', xlab='Tree age', ylab='Tree circumference', main='Growth of orange trees', lty='longdash')
```

We can also modify the thickness of the lines using the argument `lwd`. Below is an example.

```{r}
plot(Orange$age, Orange$circumference, type='l', xlab='Tree age', ylab='Tree circumference', main='Growth of orange trees', lty='longdash', lwd=1.5)
```

### `lines` {#r-lines}

`lines` draws additional lines to an existing graphic. For example, let's add lines to our orange scatter plot.

```{r}
# Original chart
plot(Orange$age, Orange$circumference, xlab='Tree age', ylab='Tree circumference', main='Growth of orange trees', pch=21, bg=Orange$Tree)

# Adding lines
lines(Orange$age, Orange$circumference)
```

The lines are too strong. It will probably be nicer to have them in a different type, such as "dotted".

```{r}
# Original chart
plot(Orange$age, Orange$circumference, xlab='Tree age', ylab='Tree circumference', main='Growth of orange trees', pch=21, bg=Orange$Tree)

# Adding lines
lines(Orange$age, Orange$circumference, lty='dotted')
```

Note that we could continue to add lines. For example, suppose we now want to add the average orange growth line.

```{r}
# Original chart
plot(Orange$age, Orange$circumference, xlab='Tree age', ylab='Tree circumference', main='Growth of orange trees', pch=21, bg=Orange$Tree)

# Adding lines
lines(Orange$age, Orange$circumference, lty='dotted')

# Getting average growth
avg_growth <- tapply(Orange$circumference, Orange$age, mean)

# Adding the average growth line
lines(unique(Orange$age), avg_growth, col='tomato', lwd=2.5)
```

We can add `lines` to any plot. Here is an example adding lines to a `barplot`.

```{r}
# Original chart
par(oma=c(3,0,0,0))
barplot(precip[1:10], las=2)

# Adding a dot-dash vertical line
lines(0:12, rep(20,13), lty='longdash') 
```

### `points` {#r-points}

`points` draws points on an existing graphic. For example, let's add the points to the line plot we did earlier.

```{r}
# Original chart
plot(Orange$age, Orange$circumference, type='l', xlab='Tree age', ylab='Tree circumference', main='Growth of orange trees')

# Adding points
points(Orange$age, Orange$circumference)
```

It's hard to see the points. It would help to have the lines be dark grey, and have the points be colored.

```{r}
# Original chart with grey lines
plot(Orange$age, Orange$circumference, type='l', xlab='Tree age', ylab='Tree circumference', main='Growth of orange trees', col='grey')

# Adding points
points(Orange$age, Orange$circumference, pch=20, col='tomato')
```

Much better!

Similar to `lines`, we can add `points` to any plot. Here is an example adding lines to a `barplot`.

```{r}
# Original chart
par(oma=c(3,0,0,0))
barplot(precip[1:10], las=2)

# Adding a dot-dash vertical line
x_values <- seq(1,10, length=10) + seq(-.3,1.5,length=10) # adjusting x positions
points(x_values, precip[1:10], pch=21, bg='steelblue') 
```

### `abline` {#r-abline}

`abline` is similar to the `lines` function. Below are some examples.

Let's add a Y=X line (with intercept=0 and slope=1).

```{r}
# Original chart
plot(cars$speed, cars$dist, xlab="Speed (mph)", ylab="Stopping distance (ft)")

# Adding Y=X line
abline(a=0, b=1) # a = intercept, b=slope
```

Let's add a horizontal line at 60.

```{r}
# Original chart
plot(cars$speed, cars$dist, xlab="Speed (mph)", ylab="Stopping distance (ft)")

# Adding a dotted horizontal line
abline(h=60, lty='dotted') 
```

Let's add a vertical line at 15.

```{r}
# Original chart
plot(cars$speed, cars$dist, xlab="Speed (mph)", ylab="Stopping distance (ft)")

# Adding a dot-dash vertical line
abline(v=15, lty='dotdash') 
```

As with `lines` and `points`, we can continue to add `abline`s.

```{r}
# Original chart
plot(cars$speed, cars$dist, xlab="Speed (mph)", ylab="Stopping distance (ft)")

# Adding Y=X line
abline(a=0, b=1) # a = intercept, b=slope

# Adding a dotted horizontal line
abline(h=60, lty='dotted') 

# Adding a dot-dash vertical line
abline(v=15, lty='dotdash') 
```

As `lines` and `points` we can add `abline`s to any plot. Here is an example adding lines to a `dotchart`.

```{r}
# Original chart
dotchart(black_hair, main='Eye color for individuals with black hair', xlab='Count', ylab='Eye color', bg='orange')

# Adding a dot-dash vertical line
abline(v=15, lty='dotdash') 
```

### `text` {#r-text}

`text` enables us to add texts to our plots. Similarly to `points`,`lines`, and `abline` we can add `text` to any plot. For the example below, we will focus on scatter plots and the built-in dataset `mtcars`.

```{r}
# Original chart
plot(mtcars$mpg, mtcars$disp, xlab='Miles/(US) gallon', ylab='Displacement (cu.in.)', pch=21, bg='orange') 

# Text with some additional comments
#   x and y enables us to select a location
text(x=29,y=460,'Note a downward trend')
```

How about making it italicized? We can change the font using the `font` argument. It takes 4 values: `1` or `plain`, `2` or `bold`, `3` or `italic`, `4`  and `bold-italic`.

```{r}
# Original chart
plot(mtcars$mpg, mtcars$disp, xlab='Miles/(US) gallon', ylab='Displacement (cu.in.)', pch=21, bg='orange') 

# Text with some additional comments
text(x=29,y=460,'Note a downward trend', font=3)
```

How about we add labels that show what cars are some (or all) of these points? We can do this using the argument `labels`.

```{r}
# Original chart
plot(mtcars$mpg, mtcars$disp, xlab='Miles/(US) gallon', ylab='Displacement (cu.in.)', pch=21, bg='orange') 

# Text with some additional comments
text(x=29,y=460,'Note a downward trend', font=3)

# Selecting some cars
subset_mtcars <- subset(mtcars, ((mpg>18&mpg<20)&disp>300))
# Label to some cars
text(x=subset_mtcars$mpg,y=subset_mtcars$disp,labels=row.names(subset_mtcars))
```

We can definitely improve the location of these labels. Let's add some offset to the x-axis. We can do this two ways: 

1. Literally add an offset to x, or
2. Use the `adj` argument.

Below is the example for option (1).

```{r}
# Original chart
plot(mtcars$mpg, mtcars$disp, xlab='Miles/(US) gallon', ylab='Displacement (cu.in.)', pch=21, bg='orange') 

# Text with some additional comments
text(x=29,y=460,'Note a downward trend', font=3)

# Label to some cars with an offset to x-axis
text(x=subset_mtcars$mpg+4.5,y=subset_mtcars$disp,labels=row.names(subset_mtcars))
```

Below is the example for option (2).

```{r}
# Original chart
plot(mtcars$mpg, mtcars$disp, xlab='Miles/(US) gallon', ylab='Displacement (cu.in.)', pch=21, bg='orange') 

# Text with some additional comments
text(x=29,y=460,'Note a downward trend', font=3)

# Label to some cars
text(x=subset_mtcars$mpg,y=subset_mtcars$disp,labels=row.names(subset_mtcars), adj=-0.1)
```

Could we decrease the size of the labels? 

```{r}
# Original chart
plot(mtcars$mpg, mtcars$disp, xlab='Miles/(US) gallon', ylab='Displacement (cu.in.)', pch=21, bg='orange') 

# Text with some additional comments
text(x=29,y=460,'Note a downward trend', font=3)

# Label to some cars
text(x=subset_mtcars$mpg,y=subset_mtcars$disp,labels=row.names(subset_mtcars), adj=-0.1, cex=.8)
```

### `mtext` {#r-mtext}

`mtext` is similar to the `text` function. However, it enables you to write in one of the four margins of the plot. Below is an example using the built-in `mtcars` dataset.

```{r}
# Original chart
plot(mtcars$mpg, mtcars$disp, xlab='Miles/(US) gallon', ylab='Displacement (cu.in.)', pch=21, bg='orange', main='Motor trend car results') 

# Adding text to the top margin:
mtext("Data from 1974 Motor Trend US magazine", font=3, cex=.7) # Recall that `cex` controls the font size.
```

### `legend` {#r-legend}

The `legend` function enables us to add legends to plots. The example below uses the built-in dataset `iris`. The scatter plot below colors the data based on the flower's species. 

```{r}
# Original chart, colors are based on species
plot(iris$Sepal.Length, iris$Sepal.Width, xlab='Sepal length', ylab='Sepal width', pch=21, bg=iris$Species) 
```

Let's create a legend for this plot to make it clear what the colors represent.

```{r}
# Original chart, colors are based on species
plot(iris$Sepal.Length, iris$Sepal.Width, xlab='Sepal length', ylab='Sepal width', pch=21, bg=iris$Species) 

# Adding a legend:
legend("topright", legend=unique(iris$Species), col=1:3, pc=20)
```

We can improve the look of the legend by making the points bigger, and removing the box.

```{r}
# Original chart, colors are based on species
plot(iris$Sepal.Length, iris$Sepal.Width, xlab='Sepal length', ylab='Sepal width', pch=21, bg=iris$Species) 

# Adding a legend:
legend("topright", legend=unique(iris$Species), col=1:3, pc=20,
       pt.cex = 1.5, # changing just the point size
       bty='n') # removing box
```

What if we made the legend's text smaller and italicized?

```{r}
# Original chart, colors are based on species
plot(iris$Sepal.Length, iris$Sepal.Width, xlab='Sepal length', ylab='Sepal width', pch=21, bg=iris$Species) 

# Adding a legend:
legend("topright", legend=unique(iris$Species), col=1:3, pc=20,
       cex = .9, # text size
       text.font=3, # italic text
       pt.cex = 1.5, # changing just the point size
       bty='n') # removing box
```

### `par` {#r-par}

`par` allows us to set several graphical parameters. Among the many parameters that can be set, some of the most commonly used ones are `mfrow`, `mfcol`, `mar`, and `oma`. `mfrow` and `mfcol` enables us to create a layout for plots, so that we can include several graphs side by side. `mar` and `oma` set margins using the following form `c(bottom, left, top, right)`. `oma` looks at outer margins.

Note that you can set several parameters all at once.

#### `mfrow`, `mfcol`

The example below uses the built-in data `mtcars`. `mfrow` and `mfcol` takes vector of the form `c(nr, nc)`, where `nr` represents the number of rows and `nc` the number of columns.

```{r}
par(mfrow=c(2,3)) # two rows, three columns
# Plot #1
plot(mtcars$mpg, mtcars$disp, xlab='Miles/(US) gallon', ylab='Displacement (cu.in.)', pch=21, bg='orange', main='Plot 1') 

# Plot #2
boxplot(mtcars$wt, xlab='Weight (1000 lbs)', col='steelblue',main='Plot 2')

# Plot #3
barplot(table(mtcars$vs), col=c('tomato',"#23395b"), xlab='Engine', names.arg = c('V-shaped', 'Straight'), main='Plot 3')

# Plot #4
dotchart(mtcars$mpg, pch=21, bg="#43418A", xlim=c(10, 42), xlab='Miles/(US) gallon', main='Plot 4')
text(mtcars$mpg[c(1:2, 31:32)], c(1:2, 31:32), labels=row.names(mtcars)[c(1:2, 31:32)], adj = -.2, cex = .75, font=4)

# Plot #5
pie(table(mtcars$am), labels=c('Automatic', 'Manual'), main='Plot 5')

# Plot #6
boxplot(mtcars$hp ~mtcars$am, names=c("Automatic", "Manual"), xlab='Transmission', ylab='Horsepower', col=c("#ceb888","#03A696"), main='Plot 6')
```

#### `mar`, `oma`

The example below uses the built-in data `iris`.

```{r}
# Original plot
plot(iris$Sepal.Length, iris$Sepal.Width, xlab='Sepal length', ylab='Sepal width', pch=21, bg=iris$Species) 

# Adding a legend:
legend("topright", legend=unique(iris$Species), col=1:3, pc=20,
       cex = .9, # text size
       text.font=3, # italic text
       pt.cex = 1.5, # changing just the point size
       bty='n') # removing box
```


Remove all margins.

```{r}
par(mar=c(0,0,0,0))
# Original plot
plot(iris$Sepal.Length, iris$Sepal.Width, xlab='Sepal length', ylab='Sepal width', pch=21, bg=iris$Species) 

# Adding a legend:
legend("topright", legend=unique(iris$Species), col=1:3, pc=20,
       cex = .9, # text size
       text.font=3, # italic text
       pt.cex = 1.5, # changing just the point size
       bty='n') # removing box
```


Add larger margins on the bottom and left side.

```{r}
par(mar=c(4,6,2,2))
# Original plot
plot(iris$Sepal.Length, iris$Sepal.Width, xlab='Sepal length', ylab='Sepal width', pch=21, bg=iris$Species) 

# Adding a legend:
legend("topright", legend=unique(iris$Species), col=1:3, pc=20,
       cex = .9, # text size
       text.font=3, # italic text
       pt.cex = 1.5, # changing just the point size
       bty='n') # removing box
```

How do these margins look set on two plots side by side?

```{r}
par(mar=c(4,6,2,2), mfrow=c(1,2))
# First plot
plot(iris$Sepal.Length, iris$Sepal.Width, xlab='Sepal length', ylab='Sepal width', pch=21, bg=iris$Species) 

# Adding a legend:
legend("topright", legend=unique(iris$Species), col=1:3, pc=20,
       cex = .9, # text size
       text.font=3, # italic text
       pt.cex = 1.5, # changing just the point size
       bty='n') # removing box

# Second plot
plot(iris$Petal.Length, iris$Petal.Width, xlab='Petal length', ylab='Peta width', pch=21, bg=iris$Species) 

# Adding a legend:
legend("bottomright", legend=unique(iris$Species), col=1:3, pc=20,
       cex = .9, # text size
       text.font=3, # italic text
       pt.cex = 1.5, # changing just the point size
       bty='n') # removing box
```

Doesn't look very good. Let's try setting smaller margins. Note that the default values for `mar` are `mar=c(5.1, 4.1, 4.1, 2.1)`.

```{r}
par(mar=c(4, 4, 2, 1), mfrow=c(1,2))
# First plot
plot(iris$Sepal.Length, iris$Sepal.Width, xlab='Sepal length', ylab='Sepal width', pch=21, bg=iris$Species) 

# Adding a legend:
legend("topright", legend=unique(iris$Species), col=1:3, pc=20,
       cex = .9, # text size
       text.font=3, # italic text
       pt.cex = 1.5, # changing just the point size
       bty='n') # removing box

# Second plot
plot(iris$Petal.Length, iris$Petal.Width, xlab='Petal length', ylab='Peta width', pch=21, bg=iris$Species) 

# Adding a legend:
legend("bottomright", legend=unique(iris$Species), col=1:3, pc=20,
       cex = .9, # text size
       text.font=3, # italic text
       pt.cex = 1.5, # changing just the point size
       bty='n') # removing box
```

Perhaps we don't need two legends. How about we increase the margins (outer and usual) for top and bottom to include legend at the bottom, and a join title at the top?

```{r}
par(mar=c(6, 4, 1, 1), mfrow=c(1,2), oma=c(2,0,3,0))
# First plot
plot(iris$Sepal.Length, iris$Sepal.Width, xlab='Sepal length', ylab='Sepal width', pch=21, bg=iris$Species) 

# Adding a legend
legend("bottom",legend=unique(iris$Species), col=1:3, pc=20,
       cex = .8, # text size
       text.font=3, # italic text
       pt.cex = 1.5, # changing just the point size
       bty='n',# removing box
       xpd = TRUE, horiz = TRUE, # make legend horizontal
       inset=c(2,-0.50)) # changes to x and y positions

# Second plot
plot(iris$Petal.Length, iris$Petal.Width, xlab='Petal length', ylab='Peta width', pch=21, bg=iris$Species) 

# Joint title
mtext("Results for 3 species of iris flowers", outer=TRUE, font=2)
```

### `plot_usmap` {#r-plot_usmap}

`usmap` is a package dedicated to get maps of the US by varying region types. Includes the `plot_usmap` function which allows you do easily plot state or region level data on top of a map.

First, load up the package:

```{r}
library(usmap)
```

You can generate the default map pretty easily.

```{r}
plot_usmap("states", labels=T)
```

The first argument, `regions` can be "states", "state", "counties", or "county". You can switch the borders by changing this argument.

```{r}
plot_usmap("counties", labels=T)
```
As you can see, adding the labels in this case, obfuscates our map.

```{r}
plot_usmap("counties", labels=F)
```
If we wanted to zoom in on a state, this is easy to do.

```{r}
plot_usmap("counties", include=c("IN"))
```
Of course, you can still just zoom in on a group of states, you don't have to show the county lines.

```{r}
plot_usmap("states", labels=T, include=c("IL", "MI", "IN", "OH"))
```
Pretty incredible. You can change the label colors using the `label_color` argument.

```{r}
plot_usmap("states", labels=T, include=c("IL", "MI", "IN", "OH"), label_color="gold")
```
You can even have different colors for each of the states.

```{r}
plot_usmap("states", labels=T, include=c("IL", "MI", "IN", "OH"), label_color=c("blue", "green", "gold", "tomato"))
```
Similarly, you can control the fill color using the `fill` argument.

```{r}
plot_usmap("states", labels=T, include=c("IL", "MI", "IN", "OH"), label_color=c("blue", "green", "gold", "tomato"), fill="grey")
```
You can control the border color using the `color` argument.

```{r}
plot_usmap("states", labels=T, include=c("IL", "MI", "IN", "OH"), label_color=c("blue", "green", "gold", "tomato"), fill="grey", color="white")
```
We can control the border width with the `size` argument as well.

```{r}
plot_usmap("states", labels=T, include=c("IL", "MI", "IN", "OH"), label_color=c("blue", "green", "gold", "tomato"), fill="grey", color="white", size=2)
```
Of course, it is important to be able to utilize a dataset with `plot_usmap`. To do so you must use the `data` and `values` arguments. 

The `data` argument expects a data.frame with at least two columns. One column to indicate which state or county, and another to indicate the associated values (whatever they may be). The column indicating the state or value must be named either `fips` or `state`. The other column can be anything as long as you use the `values` argument to specify the name.

```{r}
myDF <- data.frame(state=state.abb, val=datasets::state.area)
head(myDF)
```

```{r}
plot_usmap(data=myDF, values="val", labels=T, include=c("IL", "MI", "IN", "OH"))
```
To move the legend out of the way, you can use `theme` from `ggplot2`. 

```{r}
library(ggplot2)
plot_usmap(data=myDF, values="val", labels=T, include=c("IL", "MI", "IN", "OH")) +
  theme(legend.position = "right")
```
If we wanted to change the colors and way the shading works, we can use `scale_fill_continous` from `ggplot2`.

```{r}
library(ggplot2)
plot_usmap(data=myDF, values="val", labels=T, include=c("IL", "MI", "IN", "OH")) +
  theme(legend.position = "right") +
  scale_fill_continuous(low="white", high="navy")
```
It would probably look better if we had more than 4 points. Let's try with the entire US.

```{r}
library(ggplot2)
plot_usmap(data=myDF, values="val", labels=T) +
  theme(legend.position = "right") +
  scale_fill_continuous(low="white", high="navy")
```
It really puts AK's area into perspective! How about if we remove AK using the `exclude` argument?

```{r}
library(ggplot2)
plot_usmap(data=myDF, values="val", labels=T, exclude=c("AK")) +
  theme(legend.position = "right") +
  scale_fill_continuous(low="white", high="navy")
```
Note that if the `regions` argument is "state" or "states", either the state name, abbreviation, or fips code would work to identify the state. The full 5-digit fips code is required to identify counties, however. To get a fips code for a certain county, you can do the following.

```{r}
usmap::fips(state = "IN", county="Tippecanoe")
```
Note that the first 2 digits of the 5 digit fips code is the state fips code.

```{r}
usmap::fips(state = "IN")
```

What if we wanted to show area by the percentage of area that the state represents? First we would need to calculate it.

```{r}
myDF$percent_area <- myDF$val/sum(myDF$val)
```

```{r}
library(ggplot2)
plot_usmap(data=myDF, values="percent_area", labels=T) +
  theme(legend.position = "right") +
  scale_fill_continuous(low="white", high="navy")
```
After that, we can use the `scales` packages to fix the legend up.

```{r}
library(ggplot2)
plot_usmap(data=myDF, values="percent_area", labels=T) +
  theme(legend.position = "right") +
  scale_fill_continuous(low="white", high="navy", name="Percent of US area", label=scales::percent)
```
If you were working with data that would be better represented by dollars instead of percentages, you could simply change the `label` argument to `scales::dollars`.

#### Resources

**[Simple examples](https://cran.r-project.org/web/packages/usmap/vignettes/mapping.html)**

A page with some code examples and output using usmap.

**[More examples using usmap](https://cran.r-project.org/web/packages/usmap/vignettes/advanced-mapping.html)**

A page with some code examples and output using usmap. A little bit more in depth.

### `ggplot` {#r-ggplot}

### `ggmap` {#r-ggmap}

`ggmap` is an excellent package that provides a suite of functions that, among other things, allows you to map spatial data on top of static maps.

**Important note:** You _must_ set up billing in order to use Google's APIs.

#### Getting started {#r-ggmap-getting-started}

To install `ggmap`, simply run `install.packages("ggmap")`. To load the library, run `library(ggmap)`. When first using this package, you may notice you need an API key to get access to certain functionality. Follow the directions [here](https://developers.google.com/maps/documentation/maps-static/get-api-key#get-key) to get an API key. It should looks somethings like: `mQkzTpiaLYjPqXQBotesgif3EfGL2dbrNVOrogg`. 

Once you've acquired the API key, you have two options:

1. Register `ggmap` with Google for the current session:

```{r, eval=F}
library(ggmap)
register_google(key="mQkzTpiaLYjPqXQBotesgif3EfGL2dbrNVOrogg")
```

2. Register `ggmap` with Google, persistently through sessions:

```{r, eval=F}
library(ggmap)
register_google(key="mQkzTpiaLYjPqXQBotesgif3EfGL2dbrNVOrogg", write=TRUE)
```

Note that if you choose option (2), your API key will be saved within your `~/.Renviron`.

#### Examples {#r-ggmap-examples}

##### How do I get a map of West Lafayette?

<details>
    <summary>Click here for solution</summary>
```{r, eval=F}
map <- get_map(location="West Lafayette")
ggmap(map)
```
</details>

##### How do I zoom in and out on a map of West Lafayette?

<details>
    <summary>Click here for solution</summary>
```{r, eval=F}
# zoom way out
map <- get_map(location="West Lafayette", zoom=1)
ggmap(map)

# zoom in
map <- get_map(location="West Lafayette", zoom=12)
ggmap(map)
```
</details>

##### How do I add Latitude and Longitude points to a map of Purdue University?

<details>
    <summary>Click here for solution</summary>
```{r, eval=F}
points_to_add <- data.frame(latitude=c(40.433663, 40.432104, 40.428486), longitude=c(-86.916584, -86.919610, -86.920866))
map <- get_map(location="Purdue University", zoom=14)
ggmap(map) + geom_point(data = points_to_add, aes(x = longitude, y = latitude))
```
</details>

### `leaflet` {#r-leaflet}

`leaflet` is a popular JavaScript library to create interactive maps. The `leaflet` R package makes it easy to create incredible interactive maps.

#### Examples {#r-leaflet-examples}

##### How do I plot some longitude and latitude points on an interactive map? {#r-leaflet-example01}

<details>
    <summary>Click here for solution</summary>
```{r, eval=F}
library(leaflet)

points_to_plot <- data.frame(latitude=c(40.433663, 40.432104, 40.428486), longitude=c(-86.916584, -86.919610, -86.920866))

map <- leaflet()
map <- addTiles(map)
map <- addCircles(map, lng=points_to_plot$longitude, lat=points_to_plot$latitude)
map

# or another way with magrittr
library(magrittr)

leaflet(points_to_plot) %>% addTiles() %>% addCircles(lng=~longitude, lat=~latitude)
```

`magrittr` is a package that adds the `%>%` and ``%<%` operators which allow you to pipe the output of R code to more R code, much like piping in bash. You can read more about it [here](https://magrittr.tidyverse.org/).
</details>

## RMarkdown {#r-rmarkdown}

To install RMarkdown simply run the following:

```r
install.packages("rmarkdown")
```

Projects in [The Data Mine](https://datamine.purdue.edu) are all written in RMarkdown. You can download the RMarkdown file by clicking on the link at the top of each project page. Each file should end in the ".Rmd" which is the file extension commonly associated with RMarkdown files.

You can find an exemplary RMarkdown file here:

https://raw.githubusercontent.com/TheDataMine/the-examples-book/master/files/rmarkdown.Rmd

If you open this file in RStudio, and click on the "Knit" button in the upper left hand corner of IDE, you will get the resulting HTML file. Open this file in the web browser of your choice and compare and contrast the syntax in the `rmarkdown.Rmd` file and resulting output. Play around with the file, make modifications, and re-knit to gain a better understanding of the syntax. Note that similar input/output examples are shown in the [RMarkdown Cheatsheet](https://rstudio.com/wp-content/uploads/2016/03/rmarkdown-cheatsheet-2.0.pdf).

**[Click here for video](https://cdnapisec.kaltura.com/p/983291/sp/98329100/embedIframeJs/uiconf_id/29134031/partner_id/983291?iframeembed=true&playerId=kaltura_player&entry_id=1_e8yy80ax&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_xdjaii2y)**

### Code chunks

Code chunks are sections within an RMarkdown file where you can write, display, and optionally evaluate code from a variety of languages:

```{r, echo=FALSE}
names(knitr::knit_engines$get())
```

The syntax is simple:

````markdown
`r ''````{language, options...}
code here...
```
````

For example:

````markdown
`r ''````{r, echo=TRUE}
my_variable <- c(1,2,3)
my_variable
```
````

Which will render like:

```{r, echo=TRUE}
my_variable <- c(1,2,3)
my_variable
```

You can find a list of chunk options [here](https://rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf). 

#### How do I run a code chunk but not display the code above the results?
<details>
    <summary>Click here for solution</summary>
````markdown
`r ''````{r, echo=FALSE}
my_variable <- c(1,2,3)
my_variable
```
````
</details>

#### How do I include a code chunk without evaluating the code itself?
<details>
    <summary>Click here for solution</summary>
````markdown
`r ''````{r, eval=FALSE}
my_variable <- c(1,2,3)
my_variable
```
````
</details>

#### How do I prevent warning messages from being displayed?
<details>
    <summary>Click here for solution</summary>
````markdown
`r ''````{r, warning=FALSE}
my_variable <- c(1,2,3)
my_variable
```
````
</details>

#### How do I prevent error messages from being displayed?
<details>
    <summary>Click here for solution</summary>
````markdown
`r ''````{r, error=FALSE}
my_variable <- c(1,2,3)
my_variable
```
````
</details>

#### How do I run a code chunk, but not include the chunk in the final output?
<details>
    <summary>Click here for solution</summary>
````markdown
`r ''````{r, include=FALSE}
my_variable <- c(1,2,3)
my_variable
```
````
</details>

#### How do I render a figure from a chunk?
<details>
    <summary>Click here for solution</summary>
````markdown
`r ''````{r}
my_variable <- c(1,2,3)
plot(my_variable)
```
````
</details>

#### How do I create a set of slides using RMarkdown?

<details>
    <summary>Click here for solution</summary>
Please see the example Rmarkdown file [here](https://raw.githubusercontent.com/TheDataMine/the-examples-book/master/files/example_slides.Rmd). 

You can change the slide format by changing the yaml header to any of: ioslides_presentation, slidy_presentation, or beamer_presentation.

By default all first and second level headers (\# and \##, respectively) will create a new slide. To manually create a new slide, you can use \*\*\*.
</details>

### Resources {#r-markdown-resources}

**[RMarkdown Cheatsheet](https://rstudio.com/wp-content/uploads/2016/03/rmarkdown-cheatsheet-2.0.pdf)**

An excellent quick reference for RMarkdown syntax.

**[RMarkdown Reference](https://rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf)**

A thorough reference manual showing markdown input and expected output. Gives descriptions of the various chunk options, as well as output options.

**[RStudio RMarkdown Lessons](https://rmarkdown.rstudio.com/lesson-1.html)**

A set of lessons detailing the ins and outs of RMarkdown.

**[Markdown Tutorial](https://www.markdowntutorial.com/)**

RMarkdown uses Markdown syntax for its text. This is a good, interactive tutorial to learn the basics of Markdown. This tutorial is available in multiple languages.

**[RMarkdown Gallery](https://rmarkdown.rstudio.com/gallery.html)**

This gallery highlights a variety of reproducible and interactive RMarkdown documents. An excellent resource to see the power of RMarkdown.

**[RMarkdown Chapter](https://r4ds.had.co.nz/r-markdown.html)**

This is a chapter from Hadley Wickham's excellent [_R for Data Science_](https://r4ds.had.co.nz/) book that details important parts of RMarkdown.

**[RMarkdown in RStudio](https://rmarkdown.rstudio.com/articles_intro.html)**

This is a nice article that introduces RMarkdown, and guides the user through creating their own interactive document using RMarkdown in RStudio.

**[Reproducible Research](https://andrewbtran.github.io/NICAR/2017/reproducibility-rmarkdown/rmarkdown.html#reproducible_research)**

This is another good resource that introduces RMarkdown. Plenty of helpful pictures and screenshots.

## Tidyverse {#r-tidyverse}

### piping {#r-piping}

### `glimpse` {#r-glimpse}

### `filter` {#r-filter}

### `arrange` {#r-arrange}

### `mutate` {#r-mutate}

### `group_by` {#r-group-by}

### `str_extract` and `str_extract_all` {#r-str-extract}

`str_extract` and `str_extract_all` are useful functions from the `stringr` package. You can install the package by running:

```{r, eval=F}
install.packages("stringr")
```

`str_extract` extracts the text which matches the provided regular expression or pattern. Note that this differs from `grep` in a major way. `grep` simply returns the index in which a pattern match was found. `str_extract` returns the actual matching text. Note that `grep` typically returns the entire line where a match was found. `str_extract` returns only the part of the line or text that matches the pattern. 

For example:

```{r, eval=T}
text <- c("cat", "mat", "spat", "spatula", "gnat")

# All 5 "lines" of text were a match.
grep(".*at", text)
```

```{r, eval=T}
text <- c("cat", "mat", "spat", "spatula", "gnat")
stringr::str_extract(text, ".*at") 
```
As you can see, although all 5 words match our pattern and would be returned by `grep`, `str_extract` only returns the actual text that matches the pattern. In this case "spatula" is _not_ a "full" match -- the pattern ".\*at" only captures the "spat" part of "spatula". In order to capture the rest of the word you would need to add something like ".\*" to the end of the pattern:

```{r, eval=T}
text <- c("cat", "mat", "spat", "spatula", "gnat")
stringr::str_extract(text, ".*at.*") 
```
One final note is that you must double-escape certain characters in patterns because R treats backslashes as escape values for character constants ([stackoverflow](https://stackoverflow.com/questions/27721008/how-do-i-deal-with-special-characters-like-in-my-regex)). For example, to write `\(` we must first escape the `\`, so we write `\\(`. This is true for many character which would normally only be preceded by a single `\`.

#### Examples {#r-str-extract-examples}

##### How can I extract the text between parenthesis in a vector of texts?
<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
text <- c("this is easy for (you)", "there (are) challenging ones", "text is (really awesome) (ok?)")

# Search for a literal "(", followed by any amount of any text other than more parenthesis ([^()]*), followed by a literal ")".
stringr::str_extract(text, "\\([^()]*\\)")
```

To get _all_ matches, not just the first match:
```{r, eval=T}
text <- c("this is easy for (you)", "there (are) challenging ones", "text is (really awesome) more text (ok?)")

# Search for a literal "(", followed by any amount of any text (.*), followed by a literal ")".
stringr::str_extract_all(text, "\\([^()]*\\)")
```
</details>

### `lubridate` {#r-lubridate}

`lubridate` is a fantastic package that makes the typical tasks one would perform on dates, that much easier.

#### How do I convert a string "07/05/1990" to a `Date`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
library(lubridate)
dat <- "07/05/1990"
dat <- mdy(dat)
class(dat)
```
</details>

#### How do I convert a string "31-12-1990" to a `Date`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_string <- "31-12-1990"
dat <- dmy(my_string)
dat
class(dat)
```
</details>

#### How do I convert a string "31121990" to a `Date`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_string <- "31121990"
my_date <- dmy(my_string)
my_date
class(my_date)
```
</details>

#### How do I extract the day, week, month, quarter, and year from a `Date`?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
my_date <- dmy("31121990")
day(my_date)
week(my_date)
month(my_date)
quarter(my_date)
year(my_date)
```
</details>
    
### `strrep` {#r-strrep}

`strrep` is a function that allows you to repeat the characters a given number of times.

#### Examples {#r-strrep-examples}

##### How to repeat the string of characters ABC three times?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
strrep("ABC", 3)
```
</details>

##### How to get a vector in which A is repeated twice B three times and C four times?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
strrep(c("A", "B", "C"), c(2,3,4))
```
</details>

### `nchar` {#r-nchar} 

`nchar` is a function which counts the number of characters and symbols in a word or a string. Punctuation and blank spaces are counted as well.

#### Examples {#r-nchar-examples}

##### How to to find the number of characters and or symbols the word "Protozoa"?

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
nchar("Protozoa")
```
</details>

##### How to to find the number of characters and or symbols forthe following strings all at once "pneumonoultramicroscopicsilicovolcanoconiosis", "password: DatamineRocks#stat1900@"?

**Fun fact:** "pneumonoultramicroscopicsilicovolcanoconiosis" is the longest word in the English dictionary.

<details>
    <summary>Click here for solution</summary>
```{r, eval=T}
string_vector <- c("pneumonoultramicroscopicsilicovolcanoconiosis", "password: DatamineRocks#stat1900@")
nchar(string_vector)
```
</details>

### Resources {#r-lubridate-resources}

**[Lubridate Cheatsheet](https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf)**

A comprehensive cheatsheet on `lubridate`. Excellent resource to immediately begin using `lubridate`.

## data.table {#r-datatable}

## SQL in R {#r-sql}

## Scraping {#r-scraping}

## `shiny` {#r-shiny}

### Rendering images {#r-shiny-render-images}


