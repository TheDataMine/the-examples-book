= Gallaudet Training: Project 2 -- 2022

**Motivation:** In Python it is very important to understand some of the data types more depth than you would in R. Many of the data types in Python will seem very familiar. +


[cols="1,1"]
|===
|*R* |*Python*

|character |string 'str'

|integer | integer 'int'
|numeric | float

|logical | boolen 'bool'
|===


In addition to all of that, there are other classifications that  the packages in Python include. The most popular packages are `pandas` and `numpy`. +
Things like `tuple`s, `list`s, `set`s, and `dict`s that diverge from R. +
It is important to understand basic concepts in Python before jumping in.

**Context:** This is the second project introducing some basic data types, and demonstrating some familiar control flow concepts, all while digging right into a dataset.

**Scope:** tuples, lists, if statements, opening files

.Learning Objectives
****

- List the differences between lists & tuples and when to use each.
- Gain familiarity with string methods, list methods, and tuple methods.
- Demonstrate the ability to read and write data of various formats using various packages.
****

Make sure to read about, and use the template found xref:templates.adoc[here], and the important information about projects submissions xref:submissions.adoc[here].

#### Dataset

The following questions will use the dataset found in Anvil:

`/anvil/projects/tdm/data/craigslist/vehicles.csv`

== Questions

==== ONE

Read in the dataset `/anvil/projects/tdm/data/craigslist/vehicles.csv` into a `pandas` DataFrame called `myDF`. 

.Insider Knowledge
[%collapsible]
====
`pandas` is an integral tool for various data science tasks in Python. You can read a quick intro https://pandas.pydata.org/pandas-docs/stable/user_guide/10min.html[here].+
We will be slowly introducing bits and pieces of this package throughout the semester. 
====

.Helpful Hints
[%collapsible]
====
[source,python]
----
import pandas as pd
from pathlib import path 
----
====
[loweralpha]
.. How big is the dataset (in Mb or Gb)?

.Items to submit
====
- Code used to solve this problem.
- Output from running the code.
- The answers to the questions above
====


==== TWO

Using the function https://www.geeksforgeeks.org/dataframe-attributes-in-python-pandas/[attributes] to get the number of columns and rows of our dataset. How many columns and rows are there? Use f-stringsfootnote:[an improved way to format strings. Less prone to errors, faster, easier to read,  and more concise] to print a message, for example

There are 123 columns in the DataFrame +
There are 321 rows in the DataFrame!

.Insider Knowledge
[%collapsible]
====
Attributes are the different properties of a data.frame that can be used to get data/information from a particular data.frame

* index- _index()_there are two types of index in a data.frame. One being row index and the other colummn index. 
[source,python]
----
mydf.index
----

* columns- can be used ot get the label values for the columns in the dataset
[source,python]
----
mydf.columns
----

* axes- used when we want to know the value of all row labels AND column labels at the same time
[source, python]
----
mydf.axes
----

* d(ata)types- used to show the data types for each column in the data.frame
[source,python]
----
mydf.dtypes
----
* size- used to show the total number of elements/items in a data.frame
[source, python]
----
mydf.size
----
* shape- show the total number of rows and columns of a specific data.frame
[source,python]
----
mydf.shape
----
* ndim- stands for number of dimensions, this shows the number of dimensions in a specific data.frame
[source,python]
----
mydf.ndim
----
* empty- this checks to see if the data.frame is empty, if it is indeed empty it will retun TRUE but if the data.frame has elements/information then it will return FALSE
[source,python]
----
mydf.empty
----
* T- stands for _transpose_ this means that you can change rows into columns and also vice versa of columns into rows. 
[source,python]
----
mydf.T
----
* values- returns a view object which contains the values of the _dic_ as a list. 
[source,python]
----
mydf.values
----
====

.Helpful Hint
[%collapsible]
====
Earlier we learned how to read a csv file into `python`, line-by-line, and print values. +
Use the `csv` package to print _just_ the first row, which should contain the names of the columns, OR instead of using the `csv` package, use one of the `pandas` attributes from `myDF` to print the column names.
====

.Items to submit
====
- Code used to solve this problem.
- Output from running the code.
- The answers to the questions above
====

==== THREE

Use the `csv` or `pandas` package to get a list called `our_columns` that contains the column names. Add a string, "extra", to the end of `our_columns`. Print the second value in the list. Without using a loop, print the 1st, 3rd, 5th, etc. elements of the list. Print the last four elements of the list ( "state", "lat", "long", and "extra") by accessing their negative index.

##### "extra" doesn't belong in our list, you can easily remove this value from our list by doing the following:

```{python, eval=F}
our_columns.pop(25)
# or even this, as pop removes the last value by default
our_columns.pop()
```

##### BUT the problem with this solution is that you must know the index of the value you'd like to remove, and sometimes you do not know the index of the value. Instead, please show how to use a [list method](#p-list-methods) to remove "extra" by _value_ rather than by _index_.



**Relevant topics:** [csv read csv](#p-csv-pkg), [break](#p-break), [append](#p-list-methods), [indexing](#p-indexing)

```{block, type="bbox"}
**Item(s) to submit:**
- Python code used to solve the problem.
- The output from running your code.
```

##### Solution

```{python, eval=F, class.source="solution"}
our_columns = []
with open("/class/datamine/data/craigslist/vehicles.csv") as my_file:
    my_reader = csv.reader(my_file)
    for row in my_reader:
        our_columns = row
        break
our_columns.append("extra")
print(our_columns[1])
print(our_columns[::2])
print(our_columns[-4:])
print(our_columns.remove("extra"))
```

##### 4. `matplotlib` is one of the primary plotting packages in Python. You are provided with the following code:

```{python, eval=F}
my_values = tuple(myDF.loc[:, 'odometer'].dropna().to_list())
```

##### The result is a _tuple_ containing the odometer readings from all of the vehicles in our dataset. Create a lineplot of the odometer readings.

##### Well, that plot doesn't seem too informative. Let's first sort the values in our tuple:

```{python, eval=F}
my_values.sort()
```

##### What happened? A tuple is immutable. What this means is that once the contents of a tuple are declared they cannot be modified. For example:

```{python, eval=F}
# This will fail because tuples are immutable
my_values[0] = 100
```

##### You can read a good article about this [here](http://www.compciv.org/guides/python/fundamentals/tuples-immutable/). In addition, [here](https://stackoverflow.com/questions/1708510/list-vs-tuple-when-to-use-each) is a great post that gives you an idea when using a tuple might be a good idea. Okay, so let's go back to our problem. We know that lists _are_ mutable (and therefore sortable), so convert `my_values` to a list and then sort, and re-plot.

##### It looks like there are some (potential) outliers that are making our plot look a little wonky. For the sake of seeing how the plot would look, use negative indexing to plot the sorted values _minus_ the last 50 values (the 50 highest values). New new plot may not look _that_ different, that is okay.

**Hint:** To prevent plotting values on the same plot, close your plot with the `close` method, for example:

```{python, eval=F}
import matplotlib.pyplot as plt
my_values = [1,2,3,4,5]
plt.plot(my_values)
plt.show()
plt.close()
```

**Relevant topics:** [list methods](#p-list-methods), [indexing](#p-indexing), [matplotlib lineplot](#p-matplotlib-lineplot)

```{block, type="bbox"}
**Item(s) to submit:**
- Python code used to solve the problem.
- The output from running your code.
```

##### Solution

```{python, eval=F, class.source="solution"}
import matplotlib.pyplot as plt
my_values = tuple(myDF.loc[:, 'odometer'].dropna().to_list())
plt.plot(my_values)
plt.close()
my_values = list(my_values)
my_values.sort()
plt.plot(my_values)
plt.show()
plt.close()
plt.plot(my_values[:-50])
plt.show()
plt.close()
```

##### 5. We've covered a lot in this project! Use what you've learned so far to do one (or more) of the following tasks:

##### - Create a cool graphic using `matplotlib`, that summarizes some data from our dataset.

##### - Use `pandas` and your investigative skills to sift through the dataset and glean an interesting factoid.

##### - Create some commented coding examples that highlight the differences between lists and tuples. Include at least 3 examples.

**Relevant topics:** [pandas](#p-pandas), [indexing](#p-indexing), [matplotlib](#p-matplotlib)

```{block, type="bbox"}
**Item(s) to submit:**
- Python code used to solve the problem.
- The output from running your code.
```

##### Solution

```{python, eval=F, class.source="solution"}
# Could be anything.
```

---