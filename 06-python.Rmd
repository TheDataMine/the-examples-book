# Python {#python}

## Getting started {#getting-started-with-python}

### Python on Scholar {#python-on-scholar}

Each year we provide students with a working Python kernel that students are able to select and use from within https://notebook.scholar.rcac.purdue.edu/ as well as within an Rmarkdown document in https://rstudio.scholar.rcac.purdue.edu/. We ask that students use this kernel when completing all Python-related questions for the course. This ensures version consistency for Python and all packages that students will use during the academic year. In addition, this enables staff to quickly modify the Python environment for all students should the need arise.

Let's configure this so every time you access https://notebook.scholar.rcac.purdue.edu/ or https://rstudio.scholar.rcac.purdue.edu/, you will have access to the proper kernel, and the default version of python is correct. Navigate to https://rstudio.scholar.rcac.purdue.edu/, and login using your Purdue credentials.  In the menu, click `Tools > Shell...`. 

You should be presented with a shell towards the bottom left. Click within the shell, and type the following followed by pressing Enter or Return:

`/class/datamine/apps/runme`

After executing the script, in the menu, click `Session > Restart R`. 

In order to run Python within https://rstudio.scholar.rcac.purdue.edu/, log in to https://rstudio.scholar.rcac.purdue.edu/ and run the following in the Console or in an R code chunk:

```{r, eval=F}
datamine_py()
install.packages("reticulate")
```

The function `datamine_py` "activates" the Python environment we have setup for the course. Any time you want to use our environment, simply run the R function at the beginning of any R Session, _prior_ to running anything Python code chunks.

To test if the Python environment is working within https://rstudio.scholar.rcac.purdue.edu/, run the following in a Python code chunk:

```{python, eval=F}
import sys
print(sys.executable)
```

The python executable should be located in the appropriate folder in the following path: `/class/datamine/apps/python/`.

The `runme` script also adds a kernel to the list of kernels shown in https://notebook.scholar.rcac.purdue.edu/. 

To test if the kernel is available and working, navigate to https://notebook.scholar.rcac.purdue.edu/, login, click on `New`, and select the kernel matching the current year. For example, you would select `f2020-s2021` for the 2020-2021 academic year. Once the notebook has launched, you can confirm the version of Python by running the following in a code cell:

```{python, eval=F}
import sys
print(sys.executable)
```

The python executable should be located in the appropriate folder in the following path: `/class/datamine/apps/python/`.

If you already have a a Jupyter notebook running at https://notebook.scholar.rcac.purdue.edu/, you may need to refresh in order for the kernel to appear as an option in `Kernel > Change Kernel`.

If you would like to use the Python environment that is put together for this class, from within a terminal on Scholar, run the following:

```{bash, eval=F}
source /class/datamine/apps/python.sh
```

This will load the environment and `python` will launch our environment's interpreter.

### A note on indentation

In most languages indentation is for appearance only. In Python, indentation is very important. In a language, like R, for instance, a block of code is defined by curly braces. For example, the curly braces indicate the bounds of the if statement in the following code chunk:

```{r, eval=F}
my_val <- TRUE
if (my_val) {
  print("This is inside the bounds of the if statement, and will be evaluated because my_val is TRUE.")
  print("This too is inside the bounds of the if statement, and will be evaluated")
}

print("This is not longer inside the bounds of the if statement.")
```

In Python, the equivalent would be:

```{python, eval=F}
my_val = True
if my_val:
    print("This is inside the bounds of the if statement, and will be evaluated because my_val is TRUE.")
    print("This too is inside the bounds of the if statement, and will be evaluated")

print("This is not longer inside the bounds of the if statement.")
```

As you can see, there are no curly braces to indicate the bounds of the if statement. Instead, the level of indentation is used. This applies for for loops as well:

```{python, eval=T}
values = [1,2,3,4,5]
for v in values:
    print(f"v: {v}")
```


## Variables {#p-variables}

Variables are declared just like in R, but rather than using `<-` and `->`, Python uses a single `=` as is customary for most languages. You can declared variables like this:

```{python, eval=T}
my_var = 4
```

Here, we declared a variable with a value of 4.

**Important note:** _Actually_ this is _technically_ not true. Numbers between -5 and 256 (inclusive) are already pre-declared and exist within Python's memory _before_ you assigned the value to `my_var`. The `=` operator simply forces `my_var` to _point_ to that value that already exists! That is right, `my_var` is technically a pointer. 

One extremely important distinction between declaring variables in Python vs. in R is what is actually happening under the hood. Take the following code:

```{python, eval=T}
my_var = 4
new_var = my_var
my_var = my_var + 1
print(f"my_var: {my_var}\nnew_var: {new_var}")

my_var = [4,]
new_var = my_var
my_var[0] = my_var[0] + 1
print(f"my_var: {my_var}\nnew_var: {new_var}")
```

Here, the first chunk of code behaves as expected because `int`s are immutable, meaning the values cannot be changed. As a result, when we assign `my_var = my_var + 1`, `my_var`'s _value_ isn't changing, `my_var` is just being pointed to a different value of 5, which is _not_ where `new_var` points. `new_var` still points to the value of 4.

The second chunk however is dealing with a mutable `list`. We first assign the first value of our list to a value of 4. Then we assign `my_var` to `new_var`. This does _not_ copy the values of `my_var` to `new_var`, but rather `new_var` now points to the same exact object. Then, when we increment the first value in `my_var`, that same change is reflected when we print the value in `new_var`, because `new_var` and `my_var` are the same object, i.e. `new_var is my_var`.

An excellent article that goes into more detail can be found [here](https://realpython.com/pointers-in-python/). 

### None {#p-none}

`None` is a keyword used to define a null value. This would be the Python equivalent to R's `NULL`. If used in an if statement, `None` represents `False`. This does not mean `None` == `False`, in fact:

```{python}
print(None == False)
```

As you can see, although `None` can represent `False` in an if statement, they are _not_ equivalent.

### bool {#p-bool}

A `bool` has two possible values: `True` and `False`. It is important to understand that technically:

```{python}
print(True == 1)
print(False == 0)
```

With that being said, `True` is _not_ equal to numbers greater than 1:

```{python}
print(True == 2)
print(True == 3)
```

With that being said, numbers not equal to 0 evaluate to `True` when used in an if statement:

```{python}
if 3:
  print("3 evaluates to True")
  
if 4:
  print("4 evaluates to True")
  
if -1:
  print("-1 evaluates to True")
```

### str {#p-str}

`str` are strings in Python. Strings are "immutable sequences of Unicode code points". Strings can be surrounded in single quotes, double quotes, or triple quoted (with either single or double quotes):

```{python}
print(f"Single quoted text is type: {type('test')}")
print(f'Double quoted text is type: {type("test")}')
print(f"Triple quoted with single quotes: {type('''This is some text''')}")
print(f'Triple quoted with double quotes: {type("""This is some text""")}')
```

Triple quoted strings can span multiple lines. All associated whitespace will be incorporated in the string:

```{python}
my_string = """This text
spans multiple 
lines."""
print(my_string)
```

But, this would cause an error:

```{python, eval=F}
my_string = "This text, 
will throw an error"
print(my_string)
```

But, you could make it span multiple lines by adding a `\`, but newlines won't be maintained:

```{python, eval=T}
my_string = "This text, \
will throw an error"
print(my_string)
```

### int {#p-int}

`int`'s are whole numbers. For instance:

```{python}
my_var = 5
print(type(my_var))
```

`int`'s can be added, subtracted, and multiplied without changing types. With that being said, division of 2 `int`'s results in a `float` regardless of whether or not the result of the division is a whole number or not:

```{python}
print(type(6+2))
print(type(6-2))
print(type(6*2))
print(type(6/2))
```

Similarly, any calculation between an `int` and `float` results in a `float`:

```{python}
print(type(6+2.0))
print(type(6-2.0))
print(type(6*2.0))
print(type(6/2.0))
```

### float {#p-float}

`float`'s are floating point numbers, or numbers with decimals. 

```{python}
my_var = 5.0
print(type(my_var))
```

`float`'s can be converted back to `int`'s using the `int` function. This _coercion_ causes the `float` to be truncated, regardless of how close to the "next" number the float is:

```{python}
print(int(5.5))
print(int(5.49))
print(int(5.51))
print(int(5.99999))
```

### complex {#p-complex}

`complex`'s represent complex numbers. `j` can be used to represent an imaginary number. `j` must be preceded by a number, like `1j`.

```{python}
my_var = 1j
print(my_var)
print(type(my_var))
```

Arithmetic with a `complex` always results in a `complex`:

```{python, eval=T}
print(type(1j*2))
print(type(1j*2.0))
print(type(1j*1j))
```

You cannot convert to an `int` or `float`:

```{python, eval=F}
print(int(1j*1j))
print(float(1j*1j))
```

#### Resources

**[Pointers in Python](https://realpython.com/pointers-in-python/)**

An excellent article explaining what happens under the hood when declaring variables in Python.

## Printing {#p-printing}

`print` is a function in Python that allows you to... well... print. Printing values and information about a program while the program is running is still to this day one of the best methods to debug your code. This is just one good reason to learn about and feel comfortable with printing.

You can print simple string literals:

```{python, eval=T}
print("This is a simple string literal being printed...")
```

You can print all types of variables, not just strings:

```{python, eval=T}
print(int(4))
print(float(4.4))
print(False)
```
You can even mix and match what you print:

```{python, eval=T}
print("This is a string and an int:", int(4)) # notice there is a space added between the arguments to print
print("This is a string and an int and a float:", int(4), float(4.4))
print(int(4), "<- is an integer")
```

You can even do arithmetic _inside_ the `print` function:

```{python, eval=T}
print("4 + 4 =", 4+4)
```
There are a series of special characters called [escape characters](https://www.w3schools.com/python/gloss_python_escape_characters.asp) that need to be escaped with a `\`, but that represent a different symbol when processed. For example, a newline character is `\n`, but when you print `\n` it results in a new line:

```{python, eval=T}
print("This is line 1.\nThis is line 2.")
```
Here are a couple more escape characters:

```{python, eval=T}
print("This is a carriage return\rAs you can see it is not a visible character.")
print("This is a .\tAnd another.\tAnd now two tabs.\t\tNice.")
```

You may now be wondering, well what if I want to literally print `\t` or `\n`? There are a couple of options:

```{python, eval=T}
print("You can escape a forward slash with another forward slash: \\")
print("This would then look like: \\t \\n")
print(r"You could also add an 'r' before your string. The 'r' represents raw and will render the text literally: \t \n")
```

Similarly, if you want to use double or single quotes within double or single quotes you can escape them as well:

```{python, eval=T}
print("This sentence has \"double quotes\".")
print('This sentence has \'single quotes\'.')
```

Of course, you can mix and match quotes to avoid needing to escape:

```{python, eval=T}
print('Now it is easy to print "double quotes".')
print("Now it is easy to print 'single quotes'.")
```

### f-strings {#p-f-strings}

f-strings are extremely straightforward, useful, and fast. I would highly recommend using f-strings when the need arrives to print something more than simple text.

f-string stands for "format string". An f-string is a string literal that starts with an `f` or an `F`:

```{python, eval=T}
print(f'This is an f-string.')
print(F'This is an f-string.')
```

Of course, you can use double or single quotes, like normal:

```{python, eval=T}
print(f"This still works.")
print(F"So does this.")
```

What do f-strings do? They allow you to print expressions inline:

```{python, eval=T}
print(f"4+4={4+4}")
```
They allow you to call functions:

```{python, eval=T}
def sumthis(a, b):
  return(a+b)
  
print(f"4+4={sumthis(4,4)}")
```

Overall, they are just a really nice feature that makes printing a pleasure. You can even write multi-line f-strings:

```{python, eval=T}
first = 'First'
second = 'Second'
multiline_string = f"First line {first}." \
                    "Second line {second}."
print(multiline_string)
```
But make sure you put an `f` before each line.

```{python, eval=T}
first = 'First'
second = 'Second'
multiline_string = f"First line {first}." \
                   f"Second line {second}."
print(multiline_string)
```

Better yet, use triple quotes with the f-string to handle multiline f-strings:

```{python, eval=T}
multiline_string = f"""First line {first}.
Second line {second}."""
print(multiline_string)
```

Of course, this is not _all_ f-strings are capable of. The "format" comes from somewhere. We can format our dates and times:

```{python, eval=T}
import datetime
dt = datetime.datetime.now()
print(f'This is the datetime: {dt: %Y/%m/%d %H:%M}')
```

As you can see, the content following the `:` is used to specify the format. For numbers, you can specify the number of decimals:

```{python, eval=T}
my_float = 444.44444445
print(f'My float: {my_float:.3f}')
print(f'My float: {my_float:.5f}')
```

Or if you desire leading zeros:

```{python, eval=T}
my_float = 444.44444445
print(f'My float: {my_float:010.3f}')
print(f'My float: {my_float:010.5f}')
print(f'My float: {my_float:10.5f}')
```

Note that the first `0` means "zero pad", and the following `10` represents the total width of the result. In this case it means zero pad until the full number takes up 10 characters (including the decimal place). You could remove the intial `0` if you want to make numbers line up neatly:

```{python, eval=T}
my_float = 444.44444445
print(f'My float: {555.55}')
print(f'My float: {22}')
print(f'My float: {1234.5}')

# vs
print("\nvs.\n")

print(f'My float: {555.55:7.02f}')
print(f'My float: {22:7.02f}')
print(f'My float: {1234.5:7.02f}')
```

#### Resources

**[RealPython f-strings](https://realpython.com/python-f-strings/#f-strings-a-new-and-improved-way-to-format-strings-in-python)**

A good walkthrough on f-strings.

## Logical operators {#p-logical-operators}

Logical operators are symbols that can be used within Python to make comparisons.

Operator | Description
---------|------------
`<`      | less than
`<=`     | less than or equal to
`>`      | greater than
`>=`     | greater than or equal to
`==`     | equal to
`!=`     | not equal to
`not x`     | negation, not x
`x or y`    | x OR y
`x and y`    | x AND y
`x is y` | x and y both point to the same objects in memory
`x == y` | x and y have the same values

It may be important to give a quick example of the difference between `==` and `is`:

```{python, eval=T}
x = -5
y = -5
print(x==y) # True
print(x is y) # True

x = 256
y = 256
print(x==y) # True
print(x is y) # True

x = 257
y = 257
print(x==y) # True
print(x is y) # False
```

This may be a surprising result for some of you. What is going on here? 

Well, Python makes an optimization where numbers between -5 and 256 (inclusive) are already declared internally. When you assign one of those pre-declared values to a variable, the variable points to the already declared object, rather than re-declaring the object. 

This is why the `is` operator is `True` for the first two numbers, and `False` for 257 -- x and y literally point to the same object when `is` results in `True` and does _not_ when `is` results in `False`.

```{python, eval=T}
x = -5
y = -5
print(x==y) # True
print(x is y) # True
print(id(x))
print(id(y))

x = 256
y = 256
print(x==y) # True
print(x is y) # True
print(id(x))
print(id(y))

x = 257
y = 257
print(x==y) # True
print(x is y) # False
print(id(x))
print(id(y))
```
There are a variety of interesting behaviors highlighted in [this](https://codeburst.io/the-unseen-pitfalls-of-python-7ca57f021d08) excellent article. It would be well worthwhile to read it.

## Lists & Tuples {#p-lists-and-tuples}

Lists and tuples are two of the primary data types in Python. Lists are declared using square brackets, and contain any data type:

```{python, eval=T}
my_list = [1,2,3,4.4,"some_string"]
```

Tuples are declared using parentheses, and can contain any data type:

```{python, eval=T}
my_tuple = (1,2,3,4.4,"some_string")
```

In general, when you think "parentheses", you should think about tuples. One exception to this is when using tuple comprehensions. One may think that the following code would produce a tuple containing the values 0, 2, 4, 6, however, it instead creates a generator:

```{python, eval=T}
not_a_tuple = (i*2 for i in range(4))
print(not_a_tuple)
```
You would have to explicitly say it is a tuple to get the expected result:

```{python, eval=T}
my_tuple = tuple(i*2 for i in range(4))
print(my_tuple)
```


Lists are _mutable_, meaning you can modify the values once they've been declared:

```{python, eval=T}
my_list[1] = 100
print(my_list)
```

Tuples, are _immutable_ (not mutable). You will get an error if you try to modify a tuple:

```{python, eval=F}
# TypeError: 'tuple' object does not support item assignment
my_tuple[1] = 100
```

You can convert to and from lists and tuples easily:

```{python, eval=T}
now_a_list = list(my_tuple)
print(type(now_a_list))

now_a_tuple = tuple(my_list)
print(type(now_a_tuple))
```


### Indexing {#p-indexing}

Indexing in R and Python are similar, but have a couple of key differences. The first, and most apparent difference is Python is 0-indexed, whereas R is 1-indexed. What does this mean? In R, if we want the first item in a list, we do the following:

```{r}
my_list <- c("first", "second", "third", "fourth", "fifth")
my_list[1]
```

Take a look at what happens in Python:

```{python}
my_list = ["first", "second", "third", "fourth", "fifth"]
my_list[1]
```

As you can see, `my_list[1]` actually accesses the _second_ value. To access the first value, we do this:

```{python}
my_list[0]
```
When using the `:` this continues to hold. In R:

```{r}
my_list[1:2]
```

But, to achieve this in Python:

```{python}
my_list[0:2]
```

Additionally, Python can support a second `:` that defines a "jump". For example:

```{python}
my_list[0:5:2]
```

One last major difference is how negative indexes work. In R, they remove the value at the given position:

```{r, eval=T}
# remove the first and second values
my_list[c(-1, -2)]

# remove the first through third values
my_list[-1:-3]
```

In Python, negative indexes just mean "start from the back" instead of "start from the front". For example:

```{python, eval=T}
my_list[-1] # last value
my_list[-2] # second to last value
my_list[-5] # first value
```
Its important to be careful when using negative indexes as the its not necessarily intuitive as when `my_list[-5]` is the first value, we would expect `my_list[5]` to be the last value, when, in fact, it produces an IndexError because the last value is `my_list[4]`.

```{python, eval=F}
my_list[5] # causes an error!
```

### List methods {#p-list-methods}

A _method_ is a function for a particular _object_. When you hear or read _method_ just think function. A `list` is one example of an object. In Python, the most common objects like lists, dicts, tuples, sets, etc., all have extremely useful methods built right in!

The following is a table of list methods from [w3schools.com](https://www.w3schools.com/python/python_lists_methods.asp).

|Method|Description|
|------|-----------|
|append()|Adds an element at the end of the list|
|clear()|Removes all the elements from the list|
|copy()|Returns a copy of the list|
|count()|Returns the number of elements with the specified value|
|extend()|Add the elements of a list (or any iterable), to the end of the current list|
|index()|Returns the index of the first element with the specified value|
|insert()|Adds an element at the specified position|
|pop()|Removes the element at the specified position|
|remove()|Removes the item with the specified value|
|reverse()|Reverses the order of the list|
|sort()|Sorts the list|

#### Examples

Let's start by creating a couple of lists:

```{python, eval=T}
list_one = ["first", "second", "third", "Fourth", "fifth"]
list_two = ["sixth", "seventh", "eighth", "ninth"]
```

##### How do I add the string "tenth" to `list_two`?

<details>
    <summary>Click here for solution</summary>
```{python, eval=T}
list_two.append("tenth")
print(list_two)
```
</details>

##### How do I remove "Fourth" from `list_one` and then add "fourth" back?

<details>
    <summary>Click here for solution</summary>
```{python, eval=T}
list_one.remove("Fourth")
print(list_one)

list_one.append("fourth")
print(list_one)
```
</details>

##### How do I remove the first element, and save the value in a new variable?

<details>
    <summary>Click here for solution</summary>
```{python, eval=T}
new_variable = list_one.pop(0)
print(f'The new variable: {new_variable}')
print(f'The old list: {list_one}')
```
</details>

##### How do I combine `list_one` and `list_two` into one big list?

<details>
    <summary>Click here for solution</summary>
```{python, eval=T}
list_one.extend(list_two)
print(list_one)
```
</details>

### Tuple methods

The following is a table of tuple methods from [w3schools.com](https://www.w3schools.com/python/python_ref_tuple.asp).

|Method|Description|
|------|-----------|
|count()|Returns the number of times a specified value occurs in a tuple|
|index()|Searches the tuple for a specified value and returns the position of where it was found|

## Dicts {#p-dicts}

Dictionaries, commonly referred to as dicts, are used to store _key:value_ pairs. Under the hood, dicts are [hash tables (or hash maps)](https://en.wikipedia.org/wiki/Hash_table). Even with extremely large sets of data, dicts are able to _very_ quickly add, remove, and search for data on average. Dicts are able to accomplish this at the expense of space.

There are two ways to declare a dict, you can either use an empty or populated set of curly braces `{}`, or the `dict` keyword. 

```{python}
# Declaring dicts
my_dict_01 = {}
print(type(my_dict_01))

my_dict_02 = dict()
print(type(my_dict_02))

my_dict_03 = {"first_names": ["John", "Jill",], "last_names": ["Smith", "Johnson", "Chen"]}
print(type(my_dict_03))

my_dict_04 = dict(first_names=["John", "Jill",], last_names=["Smith", "Johnson", "Chen"])
print(type(my_dict_04))
```

Be careful! Dicts are not the only data type that utilizes the curly braces. The following is _not_ a dict, but rather a set.

```{python}
not_a_dict = {"John", "Jill", "Ellen",}
print(type(not_a_dict))
```
There are two primary ways to "get" information from a dict. One is to use the `get` method, the other is to use square brackets and strings.

```{python, eval=F}
my_dict = {"fruits": ["apple", "orange", "pear"], "person": "John", "vegetables": ["carrots", "peas"]}

# If "person" is indeed a key, they will function the same way
my_dict["person"]
my_dict.get("person")

# If the key does not exist, like below, they will not 
# function the same way.
my_dict.get("height") # Returns None when key doesn't exist
my_dict["height"] # Throws a KeyError exception because the key, "height" doesn't exist
```

The following is a table of dict methods from [w3schools.com](https://www.w3schools.com/python/python_ref_dictionary.asp).

|Method|Description|
|------|-----------|
|clear()|Removes all the elements from the dictionary|
|copy()|Returns a copy of the dictionary|
|fromkeys()|Returns a dictionary with the specified keys and value|
|get()|Returns the value of the specified key, or None if the key doesn't exist|
|items()|Returns a list containing a tuple for each key value pair|
|keys()|Returns a list containing the dictionary's keys|
|pop()|Removes and returns the element with the specified key|
|popitem()|Removes the last inserted key-value pair|
|setdefault()|Returns the value of the specified key. If the key does not exist: insert the key, with the specified value|
|update()|Updates the dictionary with the specified key-value pairs|
|values()|Returns a list of all the values in the dictionary|

## Sets {#p-sets}

The following is a table of set methods from [w3schools.com](https://www.w3schools.com/python/python_ref_set.asp).

|Method|Description|
|------|-----------|
|add()|Adds an element to the set|
|clear()|Removes all the elements from the set|
|copy()|Returns a copy of the set|
|difference()|Returns a set containing the difference between two or more sets|
|difference_update()|Removes the items in this set that are also included in another, specified set|
|discard()|Remove the specified item|
|intersection()|Returns a set, that is the intersection of two other sets|
|intersection_update()|Removes the items in this set that are not present in other, specified set(s)|
|isdisjoint()|Returns whether two sets have an intersection or not|
|issubset()|Returns whether another set contains this set or not|
|issuperset()|Returns whether this set contains another set or not|
|pop()|Removes an element from the set|
|remove()|Removes the specified element|
|symmetric_difference()|Returns a set with the symmetric differences of two sets|
|symmetric_difference_update()|Inserts the symmetric differences from this set and another|
|union()|Return a set containing the union of sets|
|update()|Update the set with the union of this set and others|

## Control flow {#p-control-flow}

Control flow in Python is pretty straightforward and simple. Whereas in R you may be less likely to use loops, in Python, loops are used all over the place!

### If/else statements {#p-if-else}

If/else statements work just like they do in R, but syntax is different. For example, in R we have:

```{r, eval=T}
value <- 44

if (value > 44) {
  print("Value is greater than 44.")
} else {
  print("Value is not greater than 44.")
}
```
In Python, the equivalent would be:

```{python, eval=T}
value = 44

if value > 44:
  print("Value is greater than 44.")
else:
  print("Value is not greater than 44.")
```
Very similar! On big difference is there is no need for curly braces around the if statement in Python. In addition, you do not _need_ to have parentheses around the if statement in Python. With that being said, you can:

```{python, eval=T}
value = 44

if (value > 44):
  print("Value is greater than 44.")
else:
  print("Value is not greater than 44.")
```
One important point is that _instead_ of using curly braces, Python has strict "tab" rules. The tabs are what indicate whether or not the following lines are _inside_ the if statement or not. For example:

```{python, eval=T}
if True:
  print("Inside the if statement.")
print("Not inside the if statement.")
```
As you can see, the spacing is critical. If you have nested if statements (an if statement inside an if statement), you just continue to add tabs to indicate inside which statement we are. 

```{python, eval=T}
if True:
  print("Inside the first if statement.")
  if True:
    print("Inside the second if statement.")
  print("Back inside the first if statement.")
print("Outside both if statements.")
```

Let's come back to this example:

```{python, eval=T}
value = 44

if value > 44:
  print("Value is greater than 44.")
else:
  print("Value is not greater than 44.")
```

This is a very common and repeated pattern where we declare a variable some way, and then immediately use it in an if statement. Python has something called a walrus operator `:=` (aptly named due to its appearance if you use your imagination). This operator allows you to declare variables inside of an expression:

```{python, eval=T}
if value := 44 > 44:
  print("Value is greater than 44.")
else:
  print("Value is not greater than 44.")
```

### For loops {#p-for-loops}

For loops are extremely common in Python. Unlike in R where you tend to see more `apply` family functions, in Python loops are common. Here is an example:

```{python, eval=T}
my_list = ["the", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog"]
for item in my_list:
    print(item)
```

Here, `item`, represents the value from `my_list` we are currently iterating on. In the first loop, `item` is "the", in the second loop, `item` is "quick", etc. `item` is _not_ a special keyword. You can call the variable that holds the current value anything you want (except a keyword like "if", "else", "def", etc.). For example:

```{python, eval=T}
my_list = ["the", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog"]
for my_special_variable in my_list:
    print(my_special_variable)
```

As you can see, the name you give the variable is of no consequence. 

You can loop over any `iterable` in Python. An `iterable` is any object that implements both the `__iter__()` and `__next__()` dunder methods. Some example of iterables include: lists, strings, tuples, sets, dicts, etc. To test if an object is `iterable`, you could do the following:

```{python, eval=T}
this_is_not_iterable = 43

try: 
    test = iter(this_is_not_iterable)
except:
    print(f'Variable is not iterable')
```

You can iterate over multiple iterables at once, for example, a list of lists, or a tuple of tuples:

```{python, eval=T}
tuple_of_tuples = (("first", 1), ("second", 2), ("third", 3))

for my_string, my_value in tuple_of_tuples:
    print(f'my_string: {my_string}, my_value: {my_value}')
```

There are a few ways to iterate through the keys and values of a dict:

```{python, eval=T}
my_dict = {"first":1, "second":2, "third":3}

for my_key in my_dict:
    print(f'key: {my_key}, value: {my_dict[my_key]}')
```

Alternatively you could use the `items` method:

```{python, eval=T}
my_dict = {"first":1, "second":2, "third":3}

for a_tuple in my_dict.items():
    print(a_tuple)
```

As you can see `items` produces a tuple at each iteration. Rather than indexing each tuple to get your desired value, Python can automatically _unpack_ the tuple like this:

```{python, eval=T}
my_dict = {"first":1, "second":2, "third":3}

for first_value, second_value in my_dict.items():
    print(f'firstval: {first_value}, secondval: {second_value}')
```

Note that this is similar to this, but in a loop:

```{python, eval=T}
first_value, second_value = ("first", 1)
print(f'firstval: {first_value}, secondval: {second_value}')
```

Although it is not commonly used, for loops also "go with" else statements in Python. For example, [this](https://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops) example from the official Python docs.

```{python, eval=T}
for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(n, 'equals', x, '*', n/x)
            break
    else:
        print(n, 'is a prime number')
```

As you can see the else statement is aligned with the for loop, not the if statement.

#### `enumerate` {#p-enumerate}

A frequent pattern is needing to access an index as you are looping through an iterable. In other languages, this value is often ready for you. For example, in C:

```{c, eval=F}
int i;

for (i = 0; i <= 10; i++) {
  printf("%d", i);
}
```

Here, `i` can be used to access a value in an array. In Python, we can automatically add an index using the `enumerate` function. For example,

```{python, eval=T}
my_list = ["the", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog"]
for idx, val in enumerate(my_list):
    print(f'The index of {val} is {idx}.')
```

If by any chance you'd like the `idx` portion (which, again, can be named anything you'd like) to start counting at 1 instead of 0, you can do that:

```{python, eval=T}
my_list = ["the", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog"]
for count, val in enumerate(my_list, start=1):
    print(f'There have been {count} words so far.')
```

#### `break` {#p-break}

`break` is a keyword in Python that stops execution and immediately jumps out of the loop, continuing execution of code immediately following the end of the loop.

```{python}
my_list = list(range(1, 11))

# this will only print "1" as 
# the loop is immediately escaped when
# break is executed
for i in my_list:
  print(i)
  break
```

In the following example, we exit the loop once we get to number "5".

```{python}
my_list = list(range(1, 11))

for i in my_list:
  print(i)
  if i == 5:
    break
```

#### `continue` {#p-continue}

`continue` is a keyword in Python that prevents any of the remaining statements in the current iteration of the loop from running, and _continues_ from the "top" of the loop on the _next_ iteration. For example,

```{python, eval=T}
my_list = (1,2,'a',3,4,'b',5)
count = 0
for i in my_list:
    if type(i) == str:
        continue
    count += 1

print(count)
```

Here, since 'a' and 'b' are strings, we execute the `continue` which then skips the `count += 1` part of the loop and begins at the next iteration.

### Finding a median {#p-median}

There are many ways to find a median in Python.  [Here is one way to do it, without having a separate sort function](https://www.programmersought.com/article/45573563620/) according to: www.programmersought.com/article/45573563620/

```{python, eval=F}
import os
import sys
 
def partition(arr, low, high):
  end = high
  key = arr[high]
  while low < high:
    while low < high and arr[low] < key:
      low = low + 1
    while low < high and arr[high] >= key:
      high = high - 1
    if low < high:
      arr[low], arr[high] = arr[high], arr[low]
    arr[high], arr[end] = arr[end], arr[high]
  return high

def getMid(arr):
  pos = 0
  if (len(arr) > 1):
    start = 0
    end = len(arr) - 1
    if len(arr) % 2 == 1:
      mid = len(arr)/2
    else:
      mid = len(arr)/2 - 1
    while start < end:
      pos = partition(arr, start, end)
      if pos == mid:
        break
      elif pos > mid:
        end = pos - 1 
      else:
        start = pos + 1
  return arr[pos]
```


### List comprehensions {#p-list-comprehensions}

List comprehensions are a nice syntactic trick that Python allows you to use. Here is an example of a list comprehension.

```{python, eval=T}
my_list = [1,2,3,4,5]
my_squares = [i**2 for i in my_list]
print(my_squares)
```

This is the equivalent of:

```{python, eval=T}
my_list = [1,2,3,4,5]
my_squares = []
for i in my_list:
    my_squares.append(i**2)
print(my_squares)
```

The former is much more concise than the latter. You can do something similar with tuples, but be careful. For example:

```{python, eval=T}
my_list = (1,2,3,4,5)
my_squares = (i**2 for i in my_list)
print(my_squares)
```

It didn't work as expected! This is because `(` and `)` are reserved for generator expressions. For example, to create a generator that keeps generating the next square:

```{python, eval=T}
my_list = (1,2,3,4,5)
my_generator = (i**2 for i in my_list)

# you can either loop through the generator
for i in my_generator:
    print(i)
  
my_generator = (i**2 for i in my_list)
# or get the next value
print(next(my_generator))
print(next(my_generator))
```

In order to get the desired result, we need to specify that we aren't desiring a generator as output, but rather a tuple:

```{python, eval=T}
my_list = (1,2,3,4,5)
my_squares = tuple(i**2 for i in my_list)
print(my_squares)
```

You can do something similar with dicts as well. For example:

```{python, eval=T}
my_dict = {"first": 1, "second": 2, "third": 3}
my_squares = {key:value**2 for key, value in my_dict.items()}
print(my_squares)
```

You can add simple if in the comprehensions as well.

```{python, eval=T}
my_list = [1,2,3,4,5]
my_odds = [v for v in my_list if v % 2 == 1]
print(my_odds)
```

You can also work through layers of nested objects.

```{python, eval=T}
my_list = [[1,2,3,4,5], [1,2,3], [1,2,3,4,5,6,7,8], [1,2,3,4,5,6,7,8,9]]
my_odds = [number for a_list in my_list for number in a_list if number % 2 == 1]
print(my_odds)
```

As you can imagine, this is probably not the best idea most of the time as it is _probably_ less clear to most people than, say:

```{python, eval=T}
my_list = [[1,2,3,4,5], [1,2,3], [1,2,3,4,5,6,7,8], [1,2,3,4,5,6,7,8,9]]
my_odds = []
for li in my_list:
    for number in li:
        if number % 2 == 1:
            my_odds.append(number)
        
print(my_odds)
```

While list comprehensions are a great feature, it is careful to not _always_ use them. Clear code is (nearly) always better code.

### Placeholders {#p-placeholders}

Sometimes, a statement is required for syntax reasons, but there aren't any tasks to perform in that block of code.
For example, if we wanted to silently ignore an exception from the following (nonsensical) function:

```{python, eval=F}
def some_function():
  raise Exception
```

We might want to write some code like this:

```{python, eval=F}
def donothing():
  dummy_var = 5

try:
  some_function()
except:
  donothing()
```

In situations like this, we can use the special `pass` keyword to signify an operation that doesn't do anything, replacing the above
example with:

```{python, eval=F}
try:
  some_function()
except:
  pass
```

It's usually a bad idea to ignore exceptions like this, since they mean something has gone wrong in your code - however,
the `pass` keyword can be useful as a placeholder for writing code later. For example:

```{python, eval=F}
# I know what helper_function() will do, but I don't feel like writing it yet.
# I would rather write some_routine() and assume that helper_function() works.

def helper_function():
  # TODO implement me!
  pass

def some_routine():
  for i in range(10):
    helper_function()
```

## Writing functions {#p-writing-functions}

In a nutshell, a function is a set of instructions or actions packaged together in a single definition or unit. Typically, function accept 0 or more _arguments_ as input, and returns 0 or more results as output. The following is an example of a function in `Python`:

```{python, eval=T}
def word_count(sentence: str) -> int:
    """
    word_count is a function that accepts a sentence as an argument,
    and returns the number of words in the sentence.

    Args:
        sentence (str): The sentence for which we are counting the words.

    Returns:
        int: The number of words in the sentence
    """
    result = len(sentence.split())
    return result
    
test_sentence = "this is a  sentence, with 7 words."
word_count(test_sentence)
```

The function is named `word_count`. The function has a single _parameter_ named `sentence`. The function returns a single value, `result`, which is the number of words in the provided sentence. `test_sentence` is the _argument_ to `word_count`. An _argument_ is the actual value passed to the function. We _pass_ values to functions -- this just means we use the values as _arguments_ to the function. The _parameter_, `sentence`, is the name shown in the function definition.

Functions can have helper functions. A helper function is a function defined and used within another function in order to reduce complexity or make the task at hand more clear. For example, let's say we wanted our function to strip all punctuation before counting the words:

```{python, eval=T}
import string

def word_count(sentence: str) -> int:
    """
    word_count is a function that accepts a sentence as an argument,
    and returns the number of words in the sentence.

    Args:
        sentence (str): The sentence for which we are counting the words.

    Returns:
        int: The number of words in the sentence
    """
    
    def _strip_punctuation(sentence: str):
        """
        helper function to strip punctuation.
        """
        return sentence.translate(str.maketrans('', '', string.punctuation))
    
    sentence_no_punc = _strip_punctuation(sentence)
    result = len(sentence_no_punc.split())
    return result
    
test_sentence = "this is a  sentence, with 7 words."
word_count(test_sentence)
```

Here, our helper function is named `_strip_punctuation`. The preceding `_` is a hint to the programmer that the function is just for internal use (just for inside the function). If you try to call `_strip_punctuation` outside of `word_count`, you will get an error. `_strip_punctuation` is defined within the scope of `word_count` and is not available outside that scope. In this example, `word_count` is the _caller_, the function that _calls_ the other function, `_strip_punctuation`. The other function, `_strip_punctuation`, can be referred to as the `callee`.

In `Python` functions can be passed to other functions as arguments. In general, functions that accept another function as an argument or return functions, are called higher order functions. Some examples of higher order functions in Python are `map`, `filter`, and `reduce`. The function passed as an argument, is often referred to as a _callback function_, as the _caller_ is expected to call back (execute) the argument at a later point in time.

### packing and unpacking

To pass any number of `n` arguments to a function, we can use argument tuple packing. For example:

```{python, eval=T}
def sum_then_multiply_by_x(x = 0, *args):
    print(args)
    return sum(args)*x

print(sum_then_multiply_by_x(2, 1, 2, 3))
print(sum_then_multiply_by_x(2, 1, 2, 3, 4))
print(sum_then_multiply_by_x(2, 1, 2, 3, 4, 5))
```

Here, every argument passed after the `x` argument is _packed_ into a tuple called `args`. As you can see, you can pass any number of arguments.

Okay, great. Then what is argument tuple unpacking? Unpacking is the process of _unpacking_ a tuple containing many values to be passed as separate values to a function. For example:

```{python, eval=T}
def print_foo_BAR(foo, bar):
    print(f'{foo}{bar.upper()}')
    
# normally we would call this function like so:
print_foo_BAR("first", "second")

# but, we can unpack a tuple of values to pass the arguments positionally
my_tuple_to_unpack = ("first", "second")
print_foo_BAR(*my_tuple_to_unpack)
```
Just like we have tuple packing and unpacking for positional arguments, we have dict packing and unpacking for keyword arguments. For example:

```{python, eval=T}
def print_arguments(**kwargs):
    for key, value in kwargs.items():
        print(f'key: {key}, value: {value}')

print_arguments(arg1="pretty", arg2="princess")
print_arguments(arg1="pretty", arg2="pretty", arg3="princess")
```

Here, instead of `kwargs` being a tuple internally, it is a dict. Likewise, we have argument dictionary unpacking as well:

```{python, eval=T}
def wild_animals(lions, tigers, bears):
    print(f'lions: {lions}')
    print(f'tigers: {tigers}')
    print(f'bears: {bears}')
    print('oh my!')
    
# normally we would call this function like so:
wild_animals(["bernice", "sandra", "arnold"], ["janice",], ('paul', 'jim', 'dwight'))

# but, we can unpack a tuple of values to pass the arguments positionally
my_dict_to_unpack = {"lions":["bernice", "sandra", "arnold"], "tigers":["janice",], "bears":('paul', 'jim', 'dwight')}
wild_animals(**my_dict_to_unpack)
```

### arguments

When calling a function, arguments are not all the same. In Python, there are _positional_ and _keyword_ arguments. For example:

```{python, eval=T}
def add_x_multiply_by_y(value: int, x: int, y: int) -> int:
    return (value+x)*y

add_x_multiply_by_y(2, 3, 4)
```

Here, `2`, `3`, and `4` are _positional_ arguments. It is using the order in which the arguments are passed in order to determine to which parameter the argument belongs. If we were to rearrange the order in which we passed our values, it would change the result:

```{python, eval=T}
def add_x_multiply_by_y(value: int, x: int, y: int) -> int:
    return (value+x)*y

add_x_multiply_by_y(2, 4, 3)
```

With that being said, we can use _keyword arguments_ to specify where we are passing our values to. For example:

```{python, eval=T}
def add_x_multiply_by_y(value: int, x: int, y: int) -> int:
    return (value+x)*y

add_x_multiply_by_y(2, y=4, x=3)
```

Now, since we specified that we are passing `4` to `y`, we get the same result from our first example. Be careful when mixing and matching _keyword_ and _positional_ arguments. _Positional_ arguments _must_ come _before_ _keyword_ arguments. For example:

```{python, eval=F}
# Error: positional argument follows keyword argument (<string>, line 5)
def add_x_multiply_by_y(value: int, x: int, y: int) -> int:
    return (value+x)*y

add_x_multiply_by_y(2, x=4, 3)
```

Just like in R, in Python, arguments can have default values. For example:

```{python, eval=T}
def add_x_multiply_by_y(value: int, x: int, y: int = 5) -> int:
    return (value+x)*y

add_x_multiply_by_y(1, 2)
```

Here, `1` is a positional argument for `value` and `2` is a positional argument for `x`. When not provided, `y` has a default value of 5. Again, you must be careful when giving an argument a default value. You cannot have a non-default argument follow a default argument. For example:

```{python, eval=F}
# Error: non-default argument follows default argument (<string>, line 1)
def add_x_multiply_by_y(value: int = 0, x: int, y: int) -> int:
    return (value+x)*y

add_x_multiply_by_y(x=1, y=3)
```

By default, you can pass arguments as either positional or keyword arguments. With that being said, if you want to, you _can_ create arguments that are _only_ positional or _only_ keyword. The way to specify an argument as _only_ keyword, is to use tuple packing _before_ a keyword argument. For example:

```{python, eval=T}
def sum_then_multiply_by_x(*args, x) -> int:
    return sum(args)*x

sum_then_multiply_by_x(1,2,3,4, x=5)
```

Here, if you were to try and run the following, it would fail:

```{python, eval=F}
# TypeError: sum_then_multiply_by_x() missing 1 required keyword-only argument: 'x'
sum_then_multiply_by_x(1,2,3,4,5)
```

This should make sense. We do not know how many arguments will be passed to `*args`. Therefore it is _required_ that any following arguments are _required_ to be keyword arguments, otherwise the function wouldn't know where `*args` stops and the next argument begins. You may then think, but can't we put the keyword argument before `*args` and then we know the first argument, `x`, is the first argument and the remaining arguments are `*args`? No, because then `x` could also be _positional_, then, and this would work.

```{python, eval=T}
def sum_then_multiply_by_x(x, *args) -> int:
    return sum(args)*x

sum_then_multiply_by_x(1,2,3,4,5)
```

To create one or more _positional_ only arguments, simply add a `/` as a standalone argument _after_ all of the arguments which you would like to be _only_ positional. For example:

```{python, eval=F}
def sum_then_multiply_by_x(one, two, /, three, x) -> int:
    return sum([one, two, three])*x

sum_then_multiply_by_x(1,2,3,4) # all positional, will work
sum_then_multiply_by_x(1,2,three=3,x=4) # two keyword, two positional, will work
sum_then_multiply_by_x(1,two=2,three=3,x=4) # a positional only argument was passed as a keyword argument, error
```

### docstrings

docstrings are the strings inside the function immediately following the function declaration. docstrings provide documentation for the function. You can put any information you'd like in a docstring, however, it is best to carefully describe what the function does, and stay consistent in style from docstring to docstring. 

You can access a function's docstring in various ways:

```{python, eval=T}
print(word_count.__doc__)
```

```{python, eval=T}
help(word_count)
```

In addition, if you are coding in a tool like VSCode, for example, you may gain the ability to hover over a function and see its docstring and other information. For example:

![](./images/docstring01.png)

It is good practice to write docstrings for every function you write.

### annotations

Another "thing" you may have noticed from our `word_count` function if you've ever used Python in the past. In the _signature_ of our function `def word_count(sentence: str) -> int`, we have some extra, _not_ required information in the form of _function annotations_. Specifically, you could write the `word_count` function like this, but it would function just the same:

```{python, eval=T}
def word_count(sentence):
    """
    word_count is a function that accepts a sentence as an argument,
    and returns the number of words in the sentence.

    Args:
        sentence (str): The sentence for which we are counting the words.

    Returns:
        int: The number of words in the sentence
    """
    
    def _strip_punctuation(sentence: str):
        """
        helper function to strip punctuation.
        """
        return sentence.translate(str.maketrans('', '', string.punctuation))
    
    sentence_no_punc = _strip_punctuation(sentence)
    result = len(sentence_no_punc.split())
    return result
```

Here, we do not specify that `sentence` should be a `str` or that the returned result should be an `int`. When we _do_ annotate functions, it is purely a way to add metadata to our function. In large projects, function annotations are recommended. Although Python does not strictly enforce type annotations, packages like `mypy` can be added to a deployment scheme to strictly enforce it. 

### decorators

##### Write a function called `get_filename_from_url` that, given a url to a file, like https://image.shutterstock.com/image-vector/cute-dogs-line-art-border-260nw-1079902403.jpg returns the filename _with_ the extension. {#p-functions-example-01}

<details>
    <summary>Click here for solution</summary>
```{python, eval=F}
import os
from urllib.parse import urlparse

def get_filename_from_url(url: str) -> str:
    """
    Given a link to a file, return the filename with extension.

    Args:
        url (str): The url of the file.

    Returns:
        str: A string with the filename, including the file extension.
    """
    return os.path.basename(urlparse(url).path)
```
</details>

##### Write a function that, given a url to an image, and a full path to a directory, saves the image to the provided directory. By default, have the function save the images to the user's home directory in a unix-like operating system. {#p-functions-example-02}

<details>
    <summary>Click here for solution</summary>
```{python, eval=F}
import requests
from pathlib import Path
import getpass

def scrape_image(from_url: str, to_dir: str = f'/home/{getpass.getuser()}'):
    """
    Given a url to an image, scrape the image and save the image to the provided directory.
    If no directory is provided, by default, save to the user's home directory.

    Args:
        from_url (str): U
        to_dir (str, optional): [description]. Defaults to f'/home/{getpass.getuser()}'.
    """
    resp = requests.get(from_url)
    
    # this function is from the previous example
    filename = get_filename_from_url(from_url)
    
    # Make directory if doesn't already exist
    Path(to_dir).mkdir(parents=True, exist_ok=True)
    
    file = open(f'{to_dir}/{filename}', "wb")
    file.write(resp.content)
    file.close()
```
</details>

## Reading & Writing data {#p-reading-and-writing-data}

### `read_csv` 

Please see [here](#p-pandas-read_csv).

### `csv` {#p-csv-pkg}

`csv` is a Python module that is useful for reading and writing tabular data. Much like the `read.csv` function in R, the `csv` module is useful for data that is _like_ csv but not necessarily comma-separated.

To use the `csv` module, simply import it:

```{python, eval=T}
import csv
```

#### Examples

##### How do you print each row of a csv `flights_sample.csv`?

<details>
    <summary>Click here for solution</summary>
```{python, eval=T}
# my_csv_file is the variable holding the file
with open('flights_sample.csv') as my_csv_file:
    my_reader = csv.reader(my_csv_file)
    
    # each "row" here is a list where each 
    # value in the list is an element in the row
    for row in my_reader:
        print(row)
        
    # you can change the word "row" to anything you
    # would like, just make sure to change it everywhere!
    # first, we need to "reset" the file so it starts at the beginning
    my_csv_file.seek(0)
    for my_row in my_reader:
      print(my_row)
```
```{python}
# my_csv_file is the variable holding the file
with open('flights_sample.csv') as my_csv_file:
    my_reader = csv.reader(my_csv_file)
    # instead of printing a list, you can use the "join" 
    # string method to neatly format the output
    for this_row in my_reader:
      print(', '.join(this_row))
```
</details>

##### How do you print each row of a csv `grades_semi.csv`, where instead of being comma-separated, values are semi-colon-separated?

<details>
    <summary>Click here for solution</summary>
```{python, eval=T}
with open('grades_semi.csv') as my_csv_file:
    my_reader = csv.reader(my_csv_file, delimiter=';')
    for row in my_reader:
        print(row)
```
</details>

## `pathlib` {#p-pathlib}

### `Path` {#p-pathlib-path}

#### Examples

##### How do I get the size of a file in bytes? Megabytes? Gigabytes?

**Important note:** This example will fail unless you have a file called `5000_products.csv` in the same directory as you are working in. The `.` represents the current working directory. You can read more about this [here](#dots).

```{python}
from pathlib import Path
p = Path("./5000_products.csv")
size_in_bytes = p.stat().st_size
print(f'Size in bytes: {size_in_bytes}')
print(f'Size in megabytes: {size_in_bytes/1_000_000}')
print(f'Size in gigabytes: {size_in_bytes/1_000_000_000}')
```

## `numpy` {#p-numpy}

## `scipy` {#p-scipy}

## `pandas` {#p-pandas}

### `read_csv` {#p-pandas-read_csv}

`read_csv` is a function from the `pandas` library that allows you to read tabular data into a `pandas` DataFrame.

#### Examples

##### How do I read a csv file called `grades.csv` into a DataFrame? 

<details>
    <summary>Click here for solution</summary>
    
Note that the "." means the current working directory. So, if we were in "/home/john/projects", "./grades.csv" would be the same as "/home/john/projects/grades.csv". This is called a _relative_ path. Read [this](#dots) for a better understanding. 

```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./grades.csv")
myDF.head()
```
</details>

##### How do I read a csv file called `grades_semi.csv` where instead of being comma-separated, it is semi-colon-separated, into a DataFrame?

<details>
    <summary>Click here for solution</summary>
```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./grades_semi.csv", sep=";")
myDF.head()
```
</details>

##### How do I specify the type of 1 or more columns when reading in a csv file?

<details>
    <summary>Click here for solution</summary>
```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./grades.csv")
myDF.dtypes

# as you can see, year is of dtype "object"
# object dtype can hold any Python object
# we know that this column should hold strings
# so let's specify this as we read in the data
myDF = pd.read_csv("./grades.csv", dtype={"year": "string"})
myDF.dtypes

# if we wanted to specify that the "grade"
# column should be float64 instead of int64
# we could do that too
myDF = pd.read_csv("./grades.csv", dtype={"year": "string", "grade": "float64"})
myDF.dtypes

# and you can see that they are indeed floats now
myDF.head()
```
</details>

##### Given a list of csv files with the same columns, how can I read them in and combine them into a single dataframe?

<details>
    <summary>Click here for solution</summary>
```{python, eval=T}
my_csv_files = ["./grades.csv", "./grades2.csv"]

data = []
for file in my_csv_files:
    myDF = pd.read_csv(file)
    data.append(myDF)
    
final_result = pd.concat(data, axis=0)
final_result
```
</details>

### `to_csv` {#p-pandas-to_csv}

`to_csv` is a function from the `pandas` library that allows you to write/save a `pandas` DataFrame into a csv file on your computer.

#### Examples

##### How do I save the pandas DataFrame called `myDF` as a cvs file called `grades.csv` in my scratch directory? 

<details>
    <summary>Click here for solution</summary>

```{python, eval=F}
import pandas as pd
# This is the data we loaded using read_csv
myDF = pd.read_csv("./grades.csv")
# The code below saves this DataFrame as a csv file called grades.csv into your personal scratch folder
 myDF.to_csv("/scratch/scholar/UserName/grades.csv")
```
</details>

### DataFrame {#p-pandas-dataframe}

The DataFrame is one of the primary classes used from the `pandas` package. Much like data.frames in R, DataFrames in `pandas` store tabular, two-dimensional datasets. 

Most operations involve [reading a dataset into a DataFrame](#p-pandas-read_csv), accessing the DataFrame's attributes, and using the DataFrame's methods to perform operations on the underlying data or with other DataFrames.

#### Examples

##### How do I get the number of rows and columns of a DataFrame, `myDF`?

<details>
    <summary>Click here for solution</summary>
```{python}
import pandas as pd

myDF = pd.read_csv("./flights_sample.csv")

# returns a tuple where the first value is the number of rows
# and the second value is the number of columns
myDF.shape 

# number of rows
myDF.shape[0]

# number of columns
myDF.shape[1]
```
</details>

##### How do I get the column names of a DataFrame, `myDF`?

<details>
    <summary>Click here for solution</summary>
```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./flights_sample.csv")
myDF.columns
```
</details>

##### How do I change the name of a column "Year" to "year"?

<details>
    <summary>Click here for solution</summary>
```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./flights_sample.csv")

# You must set myDF equal to the result
# otherwise, myDF will remain unchanged
myDF = myDF.rename(columns={"Year": "year"})

# Alternatively, you can use the inplace
# argument to make the change directly 
# to myDF
myDF.rename(columns={"year": "YEAR"}, inplace=True)

# As you can see, since we used inplace=True
# the change has been made to myDF without
# setting myDF equal to the result of our 
# operation
myDF.columns
```
</details>

##### How do I display the first _n_ rows of a DataFrame?

<details>
    <summary>Click here for solution</summary>
```{python, eval=F}
import pandas as pd

myDF = pd.read_csv("./flights_sample.csv")

# By default, this returns 5 rows
myDF.head()

# Use the "n" parameter to return a different number of rows
myDF.head(n=10)
```
</details>

##### How can I convert a list of dicts to a DataFrame?

<details>
    <summary>Click here for solution</summary>
```{python, eval=T}
list_of_dicts = []
list_of_dicts.append({'columnA': 1, 'columnB': 2})
list_of_dicts.append({'columnB': 4, 'columnA': 1}) 

myDF = pd.DataFrame(list_of_dicts)
myDF.head()
```
</details>

#### Resources

**[DataFrame Reference](https://pandas.pydata.org/docs/reference/frame.html)**

A list of DataFrame attributes and methods, with links to detailed docs.

### Series {#p-pandas-series}

#### Resources

**[10 minute intro to pandas](https://pandas.pydata.org/pandas-docs/stable/user_guide/10min.html)**

A great introduction to `pandas`. Very quick.

### Indexing {#p-pandas-indexing}

The primary ways to index a pandas DataFrame or Series is using the `loc` and `iloc` methods. The `loc` method is primarily label based, and `iloc` is primarily integer position based. For example, given the following DataFrame:

```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./flights_sample.csv")
myDF.head()
```
If we wanted to get only the rows where `Year` is 1990, we could do this:

```{python, eval=T}
# all rows where the column "Year" is equal to 1990
myDF.loc[myDF.loc[:, 'Year'] == 1990, :]
```
Or this:

```{python, eval=T}
# all rows where the column "Year" is equal to 1990
myDF.loc[myDF['Year'] == 1990, :]
```

The `:` simply means "all rows" if it is _before_ the comma, and "all columns" if it is _after_ the comma. In the same way, having `myDF['Year'] == 1990` _before_ the first comma, means to filter rows where `myDF['Year'] == 1990` results in `True`. 

Note that you could use `iloc` instead of `loc` for any of the previous examples. Both `iloc` and `loc` allow for boolean (logical) based indexing. Since `myDF['Year'] == 1990` or `myDF.loc[:, 'Year'] == 1990` both result in a Series of True and False values, this works.

To isolate a single column/Series using `loc`, we can do the following:

```{python, eval=T}
myDF.loc[:, 'Year']

# or

myDF.iloc[:, 0] # since Year is the first column
```
You can isolate multiple columns just as easily:

```{python, eval=T}
myDF.loc[:, ('Year', 'Month')]

# or

myDF.iloc[:, 0:1]
```

Or, multiple rows:

```{python, eval=T}
print(myDF.loc[0:2,:])

# or 

print(myDF.iloc[0:2,:])
```

Note that `myDF.loc[0:1, :]` is _very_ different than `myDF.iloc[0:1,:]` even though you get the same result in this example. The former looks at the row index of the DataFrame, and the latter looks at the position. So, if we changed the row index of the DataFrame, this will become clear.

```{python, eval=T}
myDF2 = myDF.copy(deep=True)

# create a new column to be used as index
myDF2['idx'] = range(2,len(myDF2['Year'])+2)
myDF2 = myDF2.set_index("idx")
myDF2.head()

print(myDF2.loc[0:2,:])

# or 

print(myDF2.iloc[0:2,:])
```

As you can see, `loc` gets all of the rows where the row index is 0, 1, or 2 (in this case, just 2, because there is no 0 or 1 row index). `iloc` gets the rows in position 0, and 1, which happen to have row index 2, and 3 respectively.

You can also index on both rows and columns:

```{python, eval=T}
myDF.iloc[0:2, 0:2]

# or

myDF.loc[0:1, ("Year", "Month")]
```

If you want to index using multiple logic statements, for example, if you wanted to get all rows where `Year` is 1990 OR `Month` is 10, you could do the following:

```{python, eval=T}
myDF.loc[(myDF.loc[:, "Year"]==1990) | (myDF.loc[:, "Month"]==10), :]
```

Note that the parentheses are critical here. Without the parentheses, you will get an error. The following will **not** work:

```{python, eval=F}
# ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
myDF.loc[myDF.loc[:, "Year"]==1990 | myDF.loc[:, "Month"]==10, :]
```

You can use `&` for logical AND just like you can use `|` for logical OR:

```{python, eval=T}
myDF.loc[(myDF.loc[:, "Year"]==1990) & (myDF.loc[:, "Month"]==10), :]
```
#### Resources

**[10 minute intro to pandas](https://pandas.pydata.org/pandas-docs/stable/user_guide/10min.html)**

A great introduction to `pandas`. Very quick.

**[loc/iloc/indexing](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html)**

The official user guide for indexing.


## Jupyter notebooks {#p-jupyter-notebooks}

## Writing scripts {#p-writing-scripts}

### `argparse` {#p-argparse}

## Scraping {#p-scraping}

Web scraping is the process of programmatically scraping or downloading web content online and processing it into the desired format. It can roughly be broken into two steps:

1. Scraping: The process of copying content from online. Typically the scraped content is HTML, but it can vary. Both the `requests` package and `selenium` package have the capability of scraping data. 
2. Parsing: The process of programmatically extracting the desired information from the scraped content. [Xpath expressions](#xml-xpath), css selectors, and packages like `beautifulsoup4` are particularly useful for this task. `lxml`, `selenium`, and `beautifulsoup4` are all excellent packages to parse scraped content.

With `lxml` and `selenium` we can use xpath expressions to locate the information we want. With that being said, that information is often returned in a Python class with some sort of name like Element (representing an HTML element). Learning how to access the information is important. The following is an example that strives to demonstrate how to: 

1. Access the raw HTML of an element in `lxml`, `selenium`, and `beautifulsoup4`.
2. Access attributes of an element in `lxml`, `selenium`, and `beautifulsoup4`.
3. Access the values (the text between tags) of an element in `lxml`, `selenium`, and `beautifulsoup4`.
4. Access the tag name of an element in `lxml`, `selenium`, and `beautifulsoup4`.

First, let's setup the the tools to each be at the same stage -- with an element ready to go.

```{python, eval=F}
# SELENIUM SETUP
from selenium import webdriver
from selenium.webdriver.firefox.options import Options

firefox_options = Options()
firefox_options.add_argument("window-size=1920,1080")
# Headless mode means no GUI
firefox_options.add_argument("--headless")
firefox_options.add_argument("start-maximized")
firefox_options.add_argument("disable-infobars")
firefox_options.add_argument("--disable-extensions")
firefox_options.add_argument("--no-sandbox")
firefox_options.add_argument("--disable-dev-shm-usage")

# Set the location of the executable Firefox program on Scholar
firefox_options.binary_location = '/class/datamine/apps/firefox/firefox'

# Set the location of the executable geckodriver program on Scholar
driver = webdriver.Firefox(options=firefox_options, executable_path='/class/datamine/apps/geckodriver')
driver.get("https://datamine.purdue.edu")

# LXML SETUP
import requests
import lxml.html

# note that without this header, a website may give you a puzzle to solve
my_headers = {'User-Agent': 'Mozilla/5.0'}

# scrape the webpage
response = requests.get("https://datamine.purdue.edu", headers=my_headers)

# load the webpage into an lxml tree
tree = lxml.html.fromstring(response.text)

# BEAUTIFULSOUP4 SETUP
from bs4 import BeautifulSoup as bsoup

my_headers = {'User-Agent': 'Mozilla/5.0'}
html = requests.get('https://datamine.purdue.edu', headers=my_headers)
soup = bsoup(html.text)
```

At this point in time, when you see us using the `soup` object, we are using `beautifulsoup4`. When you see us using the `tree` object, we are using `lxml`. When you see us using the `driver` object, we are using `selenium`.

Scrape the entire webpage:

```{python, eval=F}
print(soup)

import lxml.html
print(lxml.html.tostring(tree))

print(driver.page_source)
```

Get and print the hero on https://datamine.purdue.edu:

````
<section class="office__hero">
  <h2>The Data Mine</h2>
  <p>Advancing data science for undergraduates through collaboration, learning, research, innovation, and entrepreneurship.
  <b>Open to all undergraduates!</b></p>
</section>
````

```{python, eval=F}
soup_element = soup.find('section', attrs={'class': 'office__hero'})
# or
soup_element = soup.find('section', class_='office__hero')
print(soup_element)

lxml_element = tree.xpath("//section[@class='office__hero']")[0]
print(lxml.html.tostring(lxml_element))

selenium_element = driver.find_element_by_xpath("//section[@class='office__hero']")
print(selenium_element.get_attribute("outerHTML"))
```

Get the tag of our elements:

```{python, eval=F}
print(soup_element.name)

print(lxml_element.tag)

print(selenium_element.tag_name)
```

Get the "class" attribute of our elements:

```{python, eval=F}
print(soup_element.attrs.get("class")[0])

print(lxml_element.attrib.get("class"))

print(selenium_element.get_attribute("class"))
```

Get and print the nested `h2` element:

```{python, eval=F}
nested_soup_element = soup_element.find('h2')
print(nested_soup_element)

nested_lxml_element = lxml_element.xpath(".//h2")[0]
print(lxml.html.tostring(nested_lxml_element))

nested_selenium_element = selenium_element.find_element_by_xpath(".//h2")
print(nested_selenium_element.get_attribute("outerHTML"))
```

Get the contents or values of the nested element:

```{python, eval=F}
print(nested_soup_element.text)

print(nested_lxml_element.text)

print(nested_selenium_element.text)
```

### `requests` {#p-requests}

`requests` is a Python package used to make web requests over HTTP. 

To summarize, HTTP is a protocol for communication between servers and clients. An example of a server would be a fancy computer running in an Amazon AWS warehouse. An example of a client would be your laptop when you are web surfing!

HTTP has _requests_ and _responses_. A client (your browser, for example), sends a _request_ to a server. The server then returns a _response_ to the client. 

HTTP has the following methods: GET, POST, PUT, HEAD, DELETE, PATCH, and OPTIONS. You can read more about those [here](https://www.w3schools.com/tags/ref_httpmethods.asp). The important thing is to realize that the `requests` package enables you to easily "use" these methods in Python. For example, the GET method is used to get data from a server:

```{python, eval=T}
import requests
response = requests.get("https://datamine.purdue.edu/")
print(response)
```

For simpler tasks, using `requests` to scrape the data, and a package like `lxml` or `beautifulsoup4` to parse the data, is appropriate.

#### Examples

##### How do I scrape the HTML from https://datamine.purdue.edu/? {#p-requests-example01}

<details>
    <summary>Click here for solution</summary>
```{python, eval=T}
response = requests.get("https://datamine.purdue.edu/")
print(response.text[:500])
```
</details>


##### How do I get the status code from the `requests` response? {#p-requests-response-code}

<details>
    <summary>Click here for solution</summary>
```{python, eval=T}
response = requests.get("https://datamine.purdue.edu/")
print(response.status_code)
```
</details>



#### Resources

**[Official documentation](https://requests.readthedocs.io/en/master/)**

The official documentation for the `requests` library.

### `lxml` 

[`lxml`](https://lxml.de/) is a package used for processing XML in Python. See [here](#p-lxml)

### `selenium` {#p-selenium}

`selenium` is an extremely powerful browser automation tool with official wrappers in Ruby, Java, Python, C#, Javascript. It is a tool that is used extensively in industry, and definitely worth while learning the basics. 

For most websites, the tool combination of `requests` and `lxml` or `beautifulsoup4` will be more than adequate, and easier to jump right in. Where `selenium` really shines is the ability to interact with the browser before, during, and after scraping and parsing data. Many websites use javascript to load various pieces of HTML as the user interacts with the browser. For example, if you browse on https://pinterest.com, you will find that if you scroll very quickly, images will take a second or so to completely load. If you were to scrape these web pages with a tool like `requests`, the content you would be scraping would just be the content that was loaded in the original state. In the case of pinterest, this would mean that the _other_ 20 pictures you wanted to scrape wouldn't be present within the scraped content.

To get by this limitation, we can use `selenium` to emulate a human browsing the web page. We can make the program "scroll down" _before_ scraping the web page, so the pictures would all be present.

Other examples that could change the web page's state, hence changing the content we scrape could be: clicking on filters, using a search bar, hovering, etc.

One other major way `selenium` differs from the other tools mentioned is the ability to interact with the browser, scrape, _and_ parse the data. It can do it all.

Unfortunately `selenium` requires more setup than other packages. To get started with selenium you must first choose a browser: Firefox, Chrome, or Safari. In addition to your chosen browser, you will need an accompanying web driver. For Firefox, the web driver is [geckodriver](https://github.com/mozilla/geckodriver/releases). For Chrome, the web driver is [ChromeDriver](https://github.com/mozilla/geckodriver/releases), and for Safari you need to [enable SafariDriver](https://www.browserstack.com/guide/run-selenium-tests-on-safari-using-safaridriver). For simplicity, we will demonstrate with Firefox and geckodriver on Scholar. 
Here are some sane configurations pre-made for you. We already have compatible Firefox and geckodriver versions available on Scholar. Note that if you were to comment out the `--headless` option, Firefox would literally launch and you could watch your program in action as it is being executed. If you wrote a program to scrape images off of a website, you'd be able to see the images load and the browser slowly scroll. Note that you would need to log in via ThinLinc to do this. By enabling headless mode, you prevent this, and just need to imagine how you would interact with a given web page. Feel free to copy and paste this code in your work.

```{python, eval=F}
from selenium import webdriver
from selenium.webdriver.firefox.options import Options

firefox_options = Options()
firefox_options.add_argument("window-size=1920,1080")
# Headless mode means no GUI
firefox_options.add_argument("--headless")
firefox_options.add_argument("start-maximized")
firefox_options.add_argument("disable-infobars")
firefox_options.add_argument("--disable-extensions")
firefox_options.add_argument("--no-sandbox")
firefox_options.add_argument("--disable-dev-shm-usage")

# Set the location of the executable Firefox program on Scholar
firefox_options.binary_location = '/class/datamine/apps/firefox/firefox'

# Set the location of the executable geckodriver program on Scholar
driver = webdriver.Firefox(options=firefox_options, executable_path='/class/datamine/apps/geckodriver')
```

#### Examples

##### How do I scrape a website using `selenium`?

<details>
    <summary>Click here for solution</summary>
```{python, eval=F}
driver = webdriver.Firefox(options=firefox_options, executable_path='/class/datamine/apps/geckodriver')
driver.get("https://datamine.purdue.edu")
print(driver.page_source[:500])
```
</details>

##### How do I scrape the office "hero" on https://datamine.purdue.edu, with all of its contents?

<details>
    <summary>Click here for solution</summary>
```{python, eval=F}
driver = webdriver.Firefox(options=firefox_options, executable_path='/class/datamine/apps/geckodriver')
driver.get("https://datamine.purdue.edu")
my_element = driver.find_element_by_xpath("//section[@class='office__hero']")
print(my_element.get_attribute("outerHTML"))
```
</details>

##### How do I scrape the office "hero" on https://datamine.purdue.edu, with all of its contents, but _without_ the outermost HTML?

<details>
    <summary>Click here for solution</summary>
```{python, eval=F}
driver = webdriver.Firefox(options=firefox_options, executable_path='/class/datamine/apps/geckodriver')
driver.get("https://datamine.purdue.edu")
my_element = driver.find_element_by_xpath("//section[@class='office__hero']")
print(my_element.get_attribute("innerHTML"))
```
</details>

##### How do I use a search bar like Google with selenium? Search for "mdw" at https://purdue.edu/directory and scrape and print the data. {#p-selenium-example01}

<details>
    <summary>Click here for solution</summary>
```{python, eval=F}
driver = webdriver.Firefox(options=firefox_options, executable_path='/class/datamine/apps/geckodriver')

# get the webpage
driver.get("https://www.purdue.edu/directory")

# isolate the search bar "input" element
element = driver.find_element_by_xpath("//input[@id='basicSearchInput']")

# use "send_keys" to type in the search bar
element.send_keys("mdw")

# just like when you use a browser, you either need to push "enter" or click on the search button
# this time, we will press enter
from selenium.webdriver.common.keys import Keys
element.send_keys(Keys.RETURN)

# just how a browser can take a few seconds to fully load, let's wait for the page to load completely
import time
time.sleep(5)

# get the table(s)
elements = driver.find_elements_by_xpath("//table[@class='more']")

# how many tables are there?
print(len(elements))
```

Alternatively, we could click on the search button instead of pressing RETURN/enter:

```{python, eval=F}
driver = webdriver.Firefox(options=firefox_options, executable_path='/class/datamine/apps/geckodriver')

# get the webpage
driver.get("https://www.purdue.edu/directory")

# isolate the search bar "input" element
element = driver.find_element_by_xpath("//input[@id='basicSearchInput']")

# use "send_keys" to type in the search bar
element.send_keys("mdw")

# find the button to execute the search
button = driver.find_element_by_xpath("//a[@id='glass']")

# click the button
button.click()

# just how a browser can take a few seconds to fully load, let's wait for the page to load completely
import time
time.sleep(5)

# get the table(s)
elements = driver.find_elements_by_xpath("//table[@class='more']")

# how many tables are there?
print(len(elements))
```


No matter which method you choose to use (click or enter), the table looks like this:

```{html}
<table class="more">
    <thead>
        <tr>
            <th scope="col" colspan="2">mark daniel ward</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th class="icon-key" scope="row">Alias</th>
            <td>mdw</td>
        </tr>
        <tr>
            <th class="icon-envelope-alt">Email</th>
            <td><a href="mailto:mdw@purdue.edu">mdw@purdue.edu</a></td>
        </tr>
        <tr>
            <th class="icon-library" scope="row">Campus</th>
            <td>west lafayette</td>
        </tr>
        <tr>
            <th class="icon-sitemap">Department</th>
            <td>statistics</td>
        </tr>
        <tr>
            <th class="icon-briefcase" scope="row">Title</th>
            <td>professor of statistics</td>
        </tr>
    </tbody>
</table>
```

And can be accessed by:

```{python, eval=F}
# note since we used find_elements_by_xpath, elements is a list. 
# If we used find_element_by_xpath, we wouldn't need the [0] part
elements[0].get_attribute("outerHTML")
```

Then, to parse through this data we could:

```{python, eval=F}
# first get the name
# note that we now use .// -- this means search starting in the current element
# if we used //, it would search the entire web page, not just our element
name = elements[0].find_element_by_xpath(".//thead/tr/th").text
print(name)

# next, get the alias
# the xpath expression here first gets the "th" element with class=icon-key. 
# we want the content of the following td element. Since the next "td" 
# element is at the same level of nesting as the "th" element, it is referred to
# as a "sibling". following-sibling::td finds the "td" sibling immediately following 
# the current "th" element
alias = elements[0].find_element_by_xpath(".//th[@class='icon-key']/following-sibling::td").text
print(alias)

# next, get the email 
# if you dont specify what the attribute is equal to, it will
# evaluate to true if there is any value, and false otherwise
email = elements[0].find_element_by_xpath(".//a[@href]").text
print(email)

# next, get the campus
campus = elements[0].find_element_by_xpath(".//th[@class='icon-sitemap']/following-sibling::td").text
print(campus)

# next, get the title
title = elements[0].find_element_by_xpath(".//th[@class='icon-briefcase']/following-sibling::td").text
print(title)
```

</details>

##### How do I scrape Shutterstock images of dogs from https://www.shutterstock.com/search/dog+side+view?

<details>
    <summary>Click here for solution</summary>
    
Start by opening your favorite browser and inspecting the HTML. Open the webpage https://www.shutterstock.com/search/dog+side+view, and right click on an image and select "Inspect Element". 

![]()

This should open a help menu towards the bottom of the browser that let's you examine the HTML. You can see that the `img` tag contains all of the information we want. Specifically, look at the link in the `src` attribute: https://image.shutterstock.com/image-photo/young-labrador-retriever-4-months-260nw-97138889.jpg. We need to write a function to scrape an image given a link like that. In addition, we first need to figure out how to extract these image links from the rest of the page. 

It looks like the class attribute is not going to be of much value as it looks like a bunch of random numbers and letters. With that being said, it looks like the `data-automation` class _could_ be useful. What if we try to extract all elements where `data-automation` is equal to `mosaic-grid-cell-image`? Let's find out. 

First, let's scrape the entire page using [requests](#p-requests):

```{python, eval=F}
import requests

response = requests.get('https://www.shutterstock.com/search/dog+side+view')
print(response.text[:500])
```

Hmm, the HTML looks like it _might_ be missing what we want. Let's find out for sure using lxml:

```{python, eval=F}
import lxml.html

tree = lxml.html.fromstring(response.text)
elements = tree.xpath("//img[@data-automation='mosaic-grid-cell-image']")
print(len(elements))
```

Actually it looks like we found ~100 elements, great! If we had received a 406 error or some HTML that indicated we were being seen as a robot, we would try adding a header that makes our requests look like they come from a Firefox browser, like this:

```{python, eval=F}
my_headers = {'User-Agent': 'Mozilla/5.0'}
html = requests.get('https://www.shutterstock.com/search/dog+side+view', headers=my_headers)
```

Great, let's continue. We want to get the `src` attribute from each element, because those links contain the paths to the images we want to scrape:

```{python, eval=F}
for element in elements:
    print(element.attrib.get("src"))
```

Unfortunately, something has gone wrong. Only the first 20 or so image links have been scraped! What is going on here? This is a classic case of a website lazy loading images. What this means is the browser is waiting to fully render the images on the page until the user has the content (images) on the screen. In fact, if you load up shutterstock and then rapidly begin to scroll down, you will notice a lag where images don't load until after a few fractions of a second. 

`requests` doesn't have the capability of scraping more images from this website -- at least not easily. This is a job better suited for `selenium` as `selenium` can completely emulate human interaction with the browser. What I mean is, what if we have `selenium` load the page up, scroll a little bit, pause, scroll a bit more, pause, and _then_ try scraping the content from the web page? Would this fix our issue? Let's find out. First, perform the "setup" steps outlined [here](#p-selenium):

**Important note:** These settings will work on Scholar. In order to do the same on your own computer you will have to install compatible binaries for Firefox and geckodriver, and modify the paths in the code below accordingly.

```{python, eval=F}
from selenium import webdriver
from selenium.webdriver.firefox.options import Options

firefox_options = Options()
firefox_options.add_argument("window-size=1920,1080")
# Headless mode means no GUI
firefox_options.add_argument("--headless")
firefox_options.add_argument("start-maximized")
firefox_options.add_argument("disable-infobars")
firefox_options.add_argument("--disable-extensions")
firefox_options.add_argument("--no-sandbox")
firefox_options.add_argument("--disable-dev-shm-usage")

# Set the location of the executable Firefox program on Scholar
firefox_options.binary_location = '/class/datamine/apps/firefox/firefox'

# Set the location of the executable geckodriver program on Scholar
driver = webdriver.Firefox(options=firefox_options, executable_path='/class/datamine/apps/geckodriver')
```

Now, let's try to scroll and see if that fixes our issues:

```{python, eval=F}
driver.get("https://www.shutterstock.com/search/dog+side+view")

# create a scroll function that emulates scrolling
import time
def scroll(driver, scroll_point):  
    driver.execute_script(f'window.scrollTo(0, {scroll_point});')
    time.sleep(5) 
    
# Needed to get the window size set right
height = driver.execute_script('return document.body.scrollHeight')
driver.set_window_size(900,height+100)

# begin scrolling a bit, 1/4 of the page at a time, maybe
scroll(driver, height/4)
scroll(driver, height*2/4)
scroll(driver, height*3/4)
scroll(driver, height)

# extract the image links
elements = driver.find_elements_by_xpath("//img[@data-automation='mosaic-grid-cell-image']")
for element in elements:
  print(element.get_attribute("src"))
```

Excellent! Worked perfectly. Okay, so the next step would be to actually follow all of those links (or crawl them) and scrape the images themselves. You can write functions to do this, or use the examples [here](#p-functions-example-01) and [here](#p-functions-example-02) to help! For convenience:

```{python, eval=F}
import os
from urllib.parse import urlparse

def get_filename_from_url(url: str) -> str:
    """
    Given a link to a file, return the filename with extension.

    Args:
        url (str): The url of the file.

    Returns:
        str: A string with the filename, including the file extension.
    """
    return os.path.basename(urlparse(url).path)
```

```{python, eval=F}
import requests
from pathlib import Path
import getpass

def scrape_image(from_url: str, to_dir: str = f'/home/{getpass.getuser()}'):
    """
    Given a url to an image, scrape the image and save the image to the provided directory.
    If no directory is provided, by default, save to the user's home directory.

    Args:
        from_url (str): U
        to_dir (str, optional): [description]. Defaults to f'/home/{getpass.getuser()}'.
    """
    resp = requests.get(from_url)
    
    # this function is from the previous example
    filename = get_filename_from_url(from_url)
    
    # Make directory if doesn't already exist
    Path(to_dir).mkdir(parents=True, exist_ok=True)
    
    file = open(f'{to_dir}/{filename}', "wb")
    file.write(resp.content)
    file.close()
```

Let's cycle through and scrape each image, now:

```{python, eval=F}
for element in elements:
    scrape_image(element.get_attribute("src"))
```

</details>

## XML {#p-xml}

XML stands for Extensible Markup Language. To read more about XML see [here](#xml).

### `lxml` {#p-lxml}

[`lxml`](https://lxml.de/) is a package used for processing XML in Python. To get started, simply import the package:

```{python, eval=T}
from lxml import etree
```

To load XML from a string, do the following:

```{python}
my_string = f"""<html>
    <head>
        <title>My Title</title>
    </head>
    <body>
        <div>
            <div class="abc123 sktoe-sldjkt dkjfg3-dlgsk">
                <div class="glkjr-slkd dkgj-0 dklfgj-00">
                    <a class="slkdg43lk dlks" href="https://example.com/123456">
                    </a>
                </div>
            </div>
            <div>
                <div class="ldskfg4">
                    <span class="slktjoe" aria-label="123 comments, 43 Retweets, 4000 likes">Love it.</span>
                </div>
            </div>
            <div data-amount="12">13</div>
        </div>
        <div>
            <div class="abc123 sktoe-sls dkjfg-dlgsk">
                <div class="glkj-slkd dkgj-0 dklfj-00">
                    <a class="slkd3lk dls" href="https://example.com/123456">
                    </a>
                </div>
            </div>
            <div>
                <div class="ldg4">
                    <span class="sktjoe" aria-label="1000 comments, 455 Retweets, 40000 likes">Love it.</span>
                </div>
            </div>
            <div data-amount="122">133</div>
        </div>
    </body>
</html>"""
tree = etree.fromstring(my_string)
```

Or, to load an XML file called `example.xml` do the following:

```{python}
tree = etree.parse("example.xml")
```

From there, you can use [xpath expressions](#xml-xpath) to parse the dataset.

#### Examples

##### How do I load a webpage I scraped using `requests` into an `lxml` tree?

<details>
    <summary>Click here for solution</summary>
```{python, eval=F}
import requests
import lxml.html

# note that without this header, a website may give you a puzzle to solve
my_headers = {'User-Agent': 'Mozilla/5.0'}

# scrape the webpage
response = requests.get("https://www.reddit.com/r/puppies/", headers=my_headers)

# load the webpage into an lxml tree
tree = lxml.html.fromstring(response.text)
```
</details>

##### How do I get the name of the root node from my `lxml` tree called `tree`?

<details>
    <summary>Click here for solution</summary>
```{python}
# remember "/" gets the node starting at the root node and "*" is a
# wildcard that means "anything"
tree.xpath("/*")[0].tag
```
</details>

##### If the root node is named "html", how do I get the name of all nested tags?

<details>
    <summary>Click here for solution</summary>
```{python}
list_of_tags = [x.tag for x in tree.xpath("/html/*")]
print(list_of_tags)

# remember, this odd syntax is just a "list comprehension". It is 
# essentially a nice short-hand way of writing a loop in Python.
# It is the exact same as:
for element in tree.xpath("/html/*"):
  print(element.tag)
```
</details>

##### How do I get the attributes of an element?

<details>
    <summary>Click here for solution</summary>
```{python}
import pandas as pd

# as you can see, this prints the attributes in a dict-like object for each div element
# in the node. 
for element in tree.xpath("//div"):
  print(element.attrib)
  
# Note, if you ever want to convert a list of dicts to a pandas dataframe
# you will need to convert to a dict.
list_of_dicts = []
for element in tree.xpath("//div"):
  list_of_dicts.append(element.attrib)

myDF = pd.DataFrame(list_of_dicts)
myDF.head() # unexpected

list_of_dicts = []
for element in tree.xpath("//div"):
  list_of_dicts.append(dict(element.attrib))

myDF = pd.DataFrame(list_of_dicts)
myDF.head() # fixed
```
</details>

##### How do I get the div elements with attribute "data-amount"?

<details>
    <summary>Click here for solution</summary>
```{python}
for element in tree.xpath("//div[@data-amount]"):
  print(element.attrib)
```
</details>

##### How do I get the div elements where data-amount is greater than 50?

<details>
    <summary>Click here for solution</summary>
```{python}
for element in tree.xpath("//div[@data-amount > 50]"):
  print(element.attrib)
```
</details>

##### How do I get the values of the span tags?

<details>
    <summary>Click here for solution</summary>
```{python}
for element in tree.xpath("//span"):
  print(element.text)
```
</details>

## Plotting {#p-plotting}

There are a variety of very powerful plotting tools in Python. Some of the primary ones include: [`matplotlib`](https://matplotlib.org), [`plotly`](https://plotly.com), [`bokeh`](bokeh), [`seaborn`](https://seaborn.pydata.org), [`plotnine`](https://plotnine.readthedocs.io/en/stable/), and [`pygal`](http://www.pygal.org/en/stable/). In R, `ggplot` tends to dominate. In Python, it would be more difficult to choose "if you have to learn one library", but that library would most likely be `matplotlib`. 

### `matplotlib` {#p-matplotlib}

To begin with `matplotlib` is easy, and straightforward.

```{python, eval=T}
import matplotlib.pyplot as plt
```

From the documentation, "`matplotlib.pyplot` is a collection of functions that make matplotlib work like MATLAB. Each `pyplot` function makes some change to a figure: e.g., create a figure, creates a plotting area in a figure, plots some lines in a plotting area, decorates the plot with labels, etc.".

You essentially create a plot, call functions that modify the plot (and the plot is preserved and modified after each change), and when you are done, close a plot.

#### barplot {#p-matplotlib-barplot}

`barplot` is a function that creates a barplot. Barplots are used to display categorical data. The following is an example of plotting some data from the precip dataset.

```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./files/precip.csv")

plt.bar(myDF['place'].iloc[:10], myDF['precip'].iloc[:10])

plt.show()
plt.close()
```

As you can see, the x-axis labels are bad. What if we turn the labels to be vertical?

```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./files/precip.csv")

plt.bar(myDF['place'].iloc[:10], myDF['precip'].iloc[:10])
plt.xticks(myDF['place'].iloc[:10], rotation='vertical')

plt.show()
plt.close()
```

Much better, however, some of the longer names go off of the plot. Let's fix this. `subplots_adjust` adjusts the position of one of the edges of the plot, as a fraction of the figure width or height. Options other than `bottom` include: `left`, `right`, `top`, as well as `wspace` and `hspace`.

```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./files/precip.csv")

plt.bar(myDF['place'].iloc[:10], myDF['precip'].iloc[:10])
plt.xticks(myDF['place'].iloc[:10], rotation='vertical')
plt.subplots_adjust(bottom=0.2)

plt.show()
plt.close()
```

This is even better, however, it would be nice to have a title and axis label(s).

```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./files/precip.csv")

plt.bar(myDF['place'].iloc[:10], myDF['precip'].iloc[:10])
plt.xticks(myDF['place'].iloc[:10], rotation='vertical')
plt.subplots_adjust(bottom=0.3)
plt.title("Average Precipitation")
plt.ylabel("Inches of rain")

plt.show()
plt.close()
```


We are getting there. Let's change the color.

```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./files/precip.csv")

plt.bar(myDF['place'].iloc[:10], myDF['precip'].iloc[:10], color="#FF826B")
plt.xticks(myDF['place'].iloc[:10], rotation='vertical')
plt.subplots_adjust(bottom=0.3)
plt.title("Average Precipitation")
plt.ylabel("Inches of rain")

plt.show()
plt.close()
```

What if we want different colors for the different cities?

```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./files/precip.csv")

colors = ("#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462", "#B3DE69", "#FCCDE5", "#D9D9D9", "#BC80BD",)

plt.bar(myDF['place'].iloc[:10], myDF['precip'].iloc[:10], color=colors)
plt.xticks(myDF['place'].iloc[:10], rotation='vertical')
plt.subplots_adjust(bottom=0.3)
plt.title("Average Precipitation")
plt.ylabel("Inches of rain")

plt.show()
plt.close()
```

What if instead of x-axis labels, we want to use a legend?

```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./files/precip.csv")

colors = ("#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462", "#B3DE69", "#FCCDE5", "#D9D9D9", "#BC80BD", "#E7FFAC", "#AFF8DB")

plt.bar(myDF['place'].iloc[:10], myDF['precip'].iloc[:10], color=colors)
plt.xticks('')
plt.subplots_adjust(bottom=0.3)
plt.title("Average Precipitation")
plt.ylabel("Inches of rain")

labels = {place:color for place, color in zip(myDF['place'].iloc[:10].to_list(), colors[:10])}
print(labels)
handles = [plt.Rectangle((0,0),1,1, color=color) for label,color in labels.items()]
plt.legend(handles=handles, labels=labels.keys())

plt.show()
plt.close()
```

Pretty good, but now we don't need so much space at the bottom, and we need to make space for that legend. We use `subplots_adjust` to modify the space at the bottom, and `loc` to move the position of the legend to the upper right (see [here](https://matplotlib.org/3.3.3/api/_as_gen/matplotlib.pyplot.legend.html#matplotlib.pyplot.legend) to see other `loc` options).

```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./files/precip.csv")

colors = ("#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462", "#B3DE69", "#FCCDE5", "#D9D9D9", "#BC80BD", "#E7FFAC", "#AFF8DB")

plt.bar(myDF['place'].iloc[:10], myDF['precip'].iloc[:10], color=colors)
plt.xticks('')
plt.subplots_adjust(bottom=0.15)
plt.title("Average Precipitation")
plt.ylabel("Inches of rain")

labels = {place:color for place, color in zip(myDF['place'].iloc[:10].to_list(), colors[:10])}
print(labels)
handles = [plt.Rectangle((0,0),1,1, color=color) for label,color in labels.items()]
plt.legend(handles=handles, labels=labels.keys(), loc=1)

plt.show()
plt.close()
```

Okay, but the legend is still covering our plot. Let's use `bbox_to_anchor` to move it.

```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./files/precip.csv")

colors = ("#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462", "#B3DE69", "#FCCDE5", "#D9D9D9", "#BC80BD", "#E7FFAC", "#AFF8DB")

plt.bar(myDF['place'].iloc[:10], myDF['precip'].iloc[:10], color=colors)
plt.xticks('')
plt.subplots_adjust(bottom=0.15)
plt.title("Average Precipitation")
plt.ylabel("Inches of rain")

labels = {place:color for place, color in zip(myDF['place'].iloc[:10].to_list(), colors[:10])}
print(labels)
handles = [plt.Rectangle((0,0),1,1, color=color) for label,color in labels.items()]
plt.legend(handles=handles, labels=labels.keys(), bbox_to_anchor=(1.3, 1))

plt.show()
plt.close()
```

Let's use `subplots_adjust` to add some space on the right side.

```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./files/precip.csv")

colors = ("#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462", "#B3DE69", "#FCCDE5", "#D9D9D9", "#BC80BD", "#E7FFAC", "#AFF8DB")

plt.bar(myDF['place'].iloc[:10], myDF['precip'].iloc[:10], color=colors)
plt.xticks('')
plt.subplots_adjust(bottom=0.15, right=.75)
plt.title("Average Precipitation")
plt.ylabel("Inches of rain")

labels = {place:color for place, color in zip(myDF['place'].iloc[:10].to_list(), colors[:10])}
print(labels)
handles = [plt.Rectangle((0,0),1,1, color=color) for label,color in labels.items()]
plt.legend(handles=handles, labels=labels.keys(), bbox_to_anchor=(1, 1))

plt.show()
plt.close()
```

Let's remove or make the legend border white.

```{python, eval=T}
import pandas as pd

myDF = pd.read_csv("./files/precip.csv")

colors = ("#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462", "#B3DE69", "#FCCDE5", "#D9D9D9", "#BC80BD", "#E7FFAC", "#AFF8DB")

plt.bar(myDF['place'].iloc[:10], myDF['precip'].iloc[:10], color=colors)
plt.xticks('')
plt.subplots_adjust(bottom=0.15, right=.75)
plt.title("Average Precipitation")
plt.ylabel("Inches of rain")

labels = {place:color for place, color in zip(myDF['place'].iloc[:10].to_list(), colors[:10])}
print(labels)
handles = [plt.Rectangle((0,0),1,1, color=color) for label,color in labels.items()]
plt.legend(handles=handles, labels=labels.keys(), bbox_to_anchor=(1, 1), edgecolor='white')

plt.show()
plt.close()
```

#### boxplot {#p-matplotlib-boxplot}

#### piechart {#p-matplotlib-piechart}

#### dotchart {#p-matplotlib-dotchart}

#### scatterplot {#p-matplotlib-scatterplot}

#### lineplot {#p-matplotlib-lineplot}

`plot` is a function that creates a lineplot. Lineplots are used to display numeric data. The following is an example of plotting some data from the Orange dataset.

First we need to import `matplotlib`, and get our dataset.

```{python, eval=T}
import matplotlib.pyplot as plt
from rdatasets import data

myDF = data("Orange")
```

Let's peek at our dataset.

```{python, eval=T}
myDF.head()
```


Then, we plot `age` on our x-axis, and `circumference` on our y-axis.

```{python, eval=T}
plt.plot(myDF['age'], myDF['circumference'])
```

Okay, that's a start, but a lineplot doesn't look quite right unless the x-axis, `age` is sorted.

```{python, eval=T}
myDF.sort_values(['age', 'circumference'], inplace=True)
plt.plot(myDF['age'], myDF['circumference'])
```

Okay, that is better. Let's add a title and axis labels.

```{python, eval=T}
myDF.sort_values(['age', 'circumference'], inplace=True)
plt.plot(myDF['age'], myDF['circumference'])
plt.title("Orange circumference by Age")
plt.xlabel("Age")
plt.ylabel("Circumference")
```

What if we wanted to change the color of the plot?

```{python, eval=T}
myDF.sort_values(['age', 'circumference'], inplace=True)
plt.plot(myDF['age'], myDF['circumference'], color="#FB8072")
plt.title("Orange circumference by Age")
plt.xlabel("Age")
plt.ylabel("Circumference")
```

How about adding another line on top of the current line?

```{python, eval=T}
import numpy as np

myDF.sort_values(['age', 'circumference'], inplace=True)
plt.plot(myDF['age'], myDF['circumference'], color="#FB8072")
plt.plot(myDF['age'], np.sin(myDF['age'])*myDF['circumference'])
plt.title("Orange circumference by Age")
plt.xlabel("Age")
plt.ylabel("Circumference")
```

Of course, we can change the texture of lines as well. Textures include: `solid`, `dashed`, `dotted`, `dashdot`.

```{python, eval=T}
import numpy as np

myDF.sort_values(['age', 'circumference'], inplace=True)
plt.plot(myDF['age'], myDF['circumference'], color="#FB8072", linestyle="dashed")
plt.plot(myDF['age'], np.sin(myDF['age'])*myDF['circumference'], linestyle="dotted")
plt.title("Orange circumference by Age")
plt.xlabel("Age")
plt.ylabel("Circumference")
```

We could zoom in on the chart by changing the axis limits using `xlim` and `ylim`. 

```{python, eval=T}
import numpy as np

myDF.sort_values(['age', 'circumference'], inplace=True)
plt.plot(myDF['age'], myDF['circumference'], color="#FB8072", linestyle="dashed")
plt.plot(myDF['age'], np.sin(myDF['age'])*myDF['circumference'], linestyle="dotted")
plt.title("Orange circumference by Age")
plt.xlabel("Age")
plt.ylabel("Circumference")
plt.xlim(950, 1250)

plt.show()
```


#### Resources {#p-matplotlib-resources}

**[Official introduction to pyplot](https://matplotlib.org/tutorials/introductory/pyplot.html#sphx-glr-tutorials-introductory-pyplot-py)**

A decent introduction to pyplot.

**[Official usage guide](https://matplotlib.org/tutorials/introductory/usage.html#sphx-glr-tutorials-introductory-usage-py)**

A detailed explaination of the anatomy of a figure, terminology used with `matplotlib`, etc. Probably more detail than most people would want.


### `plotly` {#p-plotly}

### `plotnine` {#p-plotnine}

### `pygal` {#p-pygal}

### `seaborn` {#p-seaborn}

### `bokeh` {#p-bokeh}

## Classes {#p-classes}

### Attributes

### Methods

## `tensorflow`

## `pytorch`
